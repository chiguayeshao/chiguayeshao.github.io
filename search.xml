<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Github+Hexo+NexT搭建个人博客（Windows）</title>
    <url>/2020/12/14/Github-Hexo-NexT%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88Windows%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Github-Hexo-NexT搭建个人博客（Windows）"><a href="#Github-Hexo-NexT搭建个人博客（Windows）" class="headerlink" title="Github+Hexo+NexT搭建个人博客（Windows）"></a>Github+Hexo+NexT搭建个人博客（Windows）</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol>
<li>GitHub仓库</li>
<li>安装Git</li>
<li>安装Node.js</li>
<li>安装Hexo</li>
<li>安装Next主题</li>
<li>购买域名</li>
</ol>
<span id="more"></span>

<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><ol>
<li><p>进入Git官网<a href="https://git-scm.com/download/win">下载</a></p>
</li>
<li><p>根据你的电脑选择64位或32位版本</p>
<p><img src="https://i.loli.net/2020/12/14/uDjagzShdHbJs6M.png" alt="image-20201214215323884"></p>
</li>
<li><p>无脑点击下一步，直到安装完成</p>
</li>
</ol>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><ol>
<li><p>进入Node官网<a href="https://nodejs.org/en/download/">下载</a></p>
</li>
<li><p>根据你的电脑选择64位或32位版本</p>
<p><img src="https://i.loli.net/2020/12/14/7TdBAfmkriUSnKy.png" alt="image-20201214215254079"></p>
</li>
<li><p>无脑点击下一步，直到安装完成</p>
</li>
<li><p>测试是否安装成功：注意安装Node会同时安装npm</p>
<ul>
<li><p>打开命令行工具，输入<code>git -v</code> 查看Node是否安装成功</p>
</li>
<li><p>如图，显示Git版本则安装成功</p>
<p><img src="https://i.loli.net/2020/12/14/2Nm7nexZw31Cubp.png" alt="image-20201214221400043"></p>
</li>
<li><p>打开命令行工具，输入<code>npm -v</code> 查看npm是否安装成功</p>
</li>
<li><p>如图，显示npm版本则安装成功</p>
<p><img src="https://i.loli.net/2020/12/14/6OWRcPpxjGgl5Ls.png" alt="image-20201214221424224"></p>
</li>
</ul>
</li>
</ol>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><ol>
<li><p>选择合适的位置创建一个文件夹</p>
</li>
<li><p>输入cmd，打开命令行工具并定位到该文件夹</p>
<p><img src="https://i.loli.net/2020/12/14/KvIb7apfV9ASxOh.png" alt="image-20201214222613531"></p>
</li>
<li><p>使用npm命令安装Hexo</p>
<p><code>npm install hexo-cli -g</code></p>
</li>
<li><p>使用Hexo初始化博客</p>
<p><code>hexo init blogName</code></p>
<ul>
<li>blogName是你想要的任意名字</li>
<li>将创建出一个名为blogName的文件夹</li>
</ul>
</li>
<li><p>检查博客状态</p>
<ol>
<li><p>按顺序输入命令</p>
<p><code>hexo g</code></p>
<p><code>hexo s</code></p>
</li>
<li><p>在浏览器中输入loclhost:4000</p>
</li>
</ol>
</li>
<li><p>如图，博客初具形态，由于我做过些配置修改，因此和你的页面显示不完全一样。</p>
<p><img src="https://i.loli.net/2020/12/14/QZJR9ncsrTl5twm.png" alt="image-20201214221612356"></p>
</li>
</ol>
<h2 id="Github创建仓库"><a href="#Github创建仓库" class="headerlink" title="Github创建仓库"></a>Github创建仓库</h2><ol>
<li><p>Repository name需要创建为 username.github.io</p>
<ul>
<li>username是你的Github用户名</li>
</ul>
</li>
<li><p>使用Git Bash配置ssh密钥，连接GitHub</p>
<p><img src="https://i.loli.net/2020/12/14/TugAJGOYsCQf7mh.png" alt="image-20201214221753832"></p>
<ul>
<li><p>输入以下命令，设置username和useremail</p>
<p><code>git config --global user.name &quot;你的GitHub用户名&quot;</code></p>
<p><code>git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></p>
</li>
<li><p>输入以下命令生成密钥文件(无脑回车)</p>
<p><code>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</code></p>
</li>
<li><p>找到密钥文件，一般在C:\Users\username.ssh路径下，复制密钥内容</p>
<p><img src="https://i.loli.net/2020/12/14/c19gwksSavRVdym.png" alt="image-20201214222149511"></p>
</li>
<li><p>进入Github Setting页面</p>
<p><img src="https://i.loli.net/2020/12/14/doeuLRa9mj58ZfW.png" alt="image-20201214222315041"></p>
</li>
<li><p>new SSH KEY</p>
<p><img src="https://i.loli.net/2020/12/14/AFa91eMnJWgSIti.png" alt="image-20201214222419096"></p>
<ul>
<li><p>title随意，key输入刚刚复制的密钥内容</p>
<p><img src="https://i.loli.net/2020/12/14/3kt7D8MKSFv12go.png" alt="image-20201214222512434"></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>至此配置完毕，将博客推送至GitHub，执行以下命令<br><code>hexo clean</code></p>
<p><code>hexo g</code></p>
<p><code>hexo d</code></p>
<ul>
<li>可以看到GitHub中已经有了我们的博客文件</li>
</ul>
</li>
<li><p>在浏览器中输入username.github.io访问博客</p>
</li>
</ol>
<h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><ol>
<li><p>购买域名我推荐使用美区<a href="https://www.godaddy.com/offers/brand/new?isc=gofd2001aj&gclid=CjwKCAiAlNf-BRB_EiwA2osbxfBGER8_uvJGversF6txxsoGmWe-xcdK-SKtMlx08j7nU5M105M1gxoCU4cQAvD_BwE&gclsrc=aw.ds">Godaddy</a>（需要科学上网），其他途径如阿里云，腾讯云等可自行购买</p>
</li>
<li><p>注册Godaddy</p>
</li>
<li><p>输入你想要的域名</p>
<p><img src="https://i.loli.net/2020/12/14/bryT2CNck3MYxt5.png" alt="image-20201214215405386"></p>
</li>
<li><p>根据经济实力选择购买域名</p>
</li>
<li><p>配置域名，将域名与博客绑定</p>
<ul>
<li><p>进入Godaddy控制面板</p>
</li>
<li><p>选择你购买的域名，点击DNS开始配置DNS</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/12/14/QoSdh5H9OwnMpqP.png" alt="image-20201214215554340"></p>
<ul>
<li><p>添加一条A记录，value填入ip地址（ip地址通过 <code>ping username.github.io</code>获得）</p>
<p><img src="https://i.loli.net/2020/12/14/zyV31FjWvq4KoQm.png" alt="image-20201214221158651"></p>
</li>
<li><p>添加一条CNAME记录，value填入username.github.io`</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/12/14/NTOSvQCJo3rgdyw.png" alt="image-20201214220124019"></p>
</li>
</ol>
<ol start="6">
<li><p>配置博客</p>
<ul>
<li><p>进入博客目录中的source文件夹</p>
<p><img src="https://i.loli.net/2020/12/15/79tWVbOZUAMvQpi.png" alt="image-20201214220627487"></p>
</li>
<li><p>在source文件夹中新建一个没有后缀名的文件，文件名为CNAME</p>
<p><img src="https://i.loli.net/2020/12/14/gJPBdjL4tIQi2Zf.png" alt="image-20201214220736897"></p>
</li>
<li><p>编辑CNAME文件，在文件中输入你的域名</p>
<p><img src="https://i.loli.net/2020/12/14/ZSKLxwszYn1amvH.png" alt="image-20201214220910202"></p>
</li>
</ul>
</li>
</ol>
<ol start="7">
<li>配置完毕，在浏览器中输入域名访问，测试域名是否绑定成功</li>
</ol>
<h2 id="安装NexT主题"><a href="#安装NexT主题" class="headerlink" title="安装NexT主题"></a>安装NexT主题</h2><ol>
<li><p>安装，执行以下命令</p>
<p><code>npm install hexo-theme-next</code></p>
<p><code>git clone https://github.com/next-theme/hexo-theme-next themes/next</code></p>
</li>
<li><p>修改配置文件</p>
<p><img src="https://i.loli.net/2020/12/14/HhBmITV18tAe7Nd.png" alt="image-20201214222836213"></p>
<ul>
<li>将theme的的内容更改为next</li>
<li>重新执行以下命令可使next主题生效<ul>
<li><code>hexo g</code></li>
<li><code>hexo d</code></li>
</ul>
</li>
</ul>
</li>
<li><p>NexT主题的详细操作可访问<a href="https://theme-next.iissnan.com/getting-started.html">NexT官网</a>查看进阶功能或<a href="https://github.com/next-theme/hexo-theme-next">GitHub地址</a></p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>根据Hexo<a href="https://hexo.io/zh-cn/docs/">官网文档</a>和NexT<a href="https://theme-next.iissnan.com/">官网文档</a>，我们可以高度自定义我们的博客</li>
<li>具体如何自定义使博客内容更丰富，我将在之后的文章中一一道来</li>
</ul>
]]></content>
      <categories>
        <category>博客配置与搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客增加live2d</title>
    <url>/2020/12/16/Hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0live2d/</url>
    <content><![CDATA[<h1 id="Hexo博客增加live2d插件"><a href="#Hexo博客增加live2d插件" class="headerlink" title="Hexo博客增加live2d插件"></a>Hexo博客增加live2d插件</h1><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><ol>
<li>cmd进入到你的博客文件夹路径下</li>
<li>使用 <code>npm i hexo-helper-live2d --save</code> 安装依赖</li>
</ol>
<a id="more"></a>

<ol>
<li><p>安装成功后博客的package.json文件下会自动加入该包</p>
<p><img src="https://i.loli.net/2020/12/16/M3UrCJqVPN6Zp8K.png" alt="image-20201216215110041"></p>
</li>
</ol>
<h1 id="live2d-Model下载"><a href="#live2d-Model下载" class="headerlink" title="live2d Model下载"></a>live2d Model下载</h1><ol>
<li><p>进入GitHub下载<a href="https://github.com/xiazeyu/live2d-widget-models">live2d模型</a></p>
<p><img src="https://i.loli.net/2020/12/16/VZtsIemwj1h3TDl.png" alt="image-20201216215300880"></p>
</li>
<li><p>解压出该文件夹中的packages文件</p>
</li>
<li><p>将packages文件中的model复制到博客文件夹下的node_modules文件夹中</p>
<p><img src="https://i.loli.net/2020/12/16/6sZixo5y9IRnktT.png" alt="image-20201216222846076"></p>
</li>
</ol>
<h1 id="修改博客配置文件"><a href="#修改博客配置文件" class="headerlink" title="修改博客配置文件"></a>修改博客配置文件</h1><ol>
<li><p>进入博客的配置文件_config.yml，增加以下配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#是否开启看板</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-hijiki</span> <span class="comment">#想切换模型直接修改为node_modules中的liv2d的各模型文件名称</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span> <span class="comment">#在右边显示</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span> <span class="comment">#看板的宽</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">345</span> <span class="comment">#看板的高</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span>  <span class="comment">#是否在手机进行显示</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>想要预览live2d挑选喜欢的模型可以访问该<a href="https://huaji8.top/post/live2d-plugin-2.0/">网站</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>博客配置与搭建</category>
      </categories>
      <tags>
        <tag>Live2d</tag>
      </tags>
  </entry>
  <entry>
    <title>一键配置SSL证书</title>
    <url>/2020/12/15/%E4%B8%80%E9%94%AE%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="Github-Hexo博客一键配置证书"><a href="#Github-Hexo博客一键配置证书" class="headerlink" title="Github+Hexo博客一键配置证书"></a>Github+Hexo博客一键配置证书</h1><h1 id="一键配置"><a href="#一键配置" class="headerlink" title="一键配置"></a>一键配置</h1><ol>
<li><p>进入GitHub，找到博客所部署的仓库</p>
</li>
<li><p>点击Setting</p>
<p><img src="https://i.loli.net/2020/12/15/5SH98wXszenDiQW.png" alt="image-20201215204100107"></p>
</li>
</ol>
<a id="more"></a>

<ol>
<li><p>下拉找到GitHub Pages，勾选Enforce HTTPS</p>
<p><img src="https://i.loli.net/2020/12/15/tzY2wFrpsNum3XE.png" alt="image-20201215204231362"></p>
</li>
<li><p>证书配置完毕</p>
<p><img src="https://i.loli.net/2020/12/15/qXyrSZeQd7pW5Cv.png" alt="image-20201215204310992"></p>
</li>
</ol>
<h1 id="还想bb两句"><a href="#还想bb两句" class="headerlink" title="还想bb两句"></a>还想bb两句</h1><h2 id="通过Freessl获取免费证书"><a href="#通过Freessl获取免费证书" class="headerlink" title="通过Freessl获取免费证书"></a>通过Freessl获取免费证书</h2><ol>
<li><p>获取免费证书推荐通过FreeSSl<a href="https://freessl.cn/">官网</a></p>
</li>
<li><p>输入你的域名，点击创建证书</p>
<p><img src="https://i.loli.net/2020/12/15/Pg9wuTGWRZbpXrj.png" alt="image-20201215204649089"></p>
</li>
<li><p>之后应该会要求注册登录，输入邮箱为了快速方便选择浏览器生成(推荐chrome)</p>
<p><img src="https://i.loli.net/2020/12/15/ZTPO5sM3qdgDHBk.png" alt="image-20201215204827876"></p>
</li>
<li><p>之后会自动将私钥下载到本地，并且页面会如图所示要求DNS验证</p>
<p><img src="https://i.loli.net/2020/12/15/gxUdY75pABn2amo.png" alt="image-20201215205007751"></p>
</li>
<li><p>进入域名商网站配置域名(我用的是Godaddy<a href="https://www.godaddy.com/">官网</a>，其他供应商大同小异)</p>
<ul>
<li><p>根据freessl提示配置TXT记录</p>
<ul>
<li><p>Type输入TXT</p>
</li>
<li><p>Name输入freessl的TXT记录内容</p>
<p><img src="https://i.loli.net/2020/12/15/4AVpLatovb2TkhY.png" alt="image-20201215205413553"></p>
</li>
<li><p>Value输入freessl的记录值内容</p>
<p><img src="https://i.loli.net/2020/12/15/9lPns1VMHfTkXyx.png" alt="image-20201215205458547"></p>
</li>
</ul>
</li>
<li><p>然后回到freessl点击 配置完成，检测一下</p>
</li>
<li><p>检查成功后可以点击 点击验证按钮，生成免费的SSL证书</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>博客配置与搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack基础配置</title>
    <url>/2021/06/15/Webpack%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Webpack-基础配置"><a href="#Webpack-基础配置" class="headerlink" title="Webpack 基础配置"></a>Webpack 基础配置</h1><h2 id="五个概念"><a href="#五个概念" class="headerlink" title="五个概念"></a>五个概念</h2><ol>
<li>entry 入口<ul>
<li>指示 webpack 从哪个文件开始打包</li>
</ul>
</li>
<li>output 出口<ul>
<li>打包完的文件输出到哪里去，以及如何命名</li>
</ul>
</li>
<li>loader 加载器<ul>
<li>webpack 本身只处理 js，json 等资源</li>
<li>其他资源需要借助 loader 才能解析</li>
</ul>
</li>
<li>plugins 插件<ul>
<li>扩展 webpack 功能</li>
</ul>
</li>
</ol>
<span id="more"></span>

<ol start="5">
<li>mode 模式<ul>
<li>开发模式 development</li>
<li>生产模式 production</li>
</ul>
</li>
</ol>
<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><ol>
<li>基础配置文件<ul>
<li>在根目录创建 <code>webpack.config.js</code>文件</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node.js的核心模块，专门处理文件路径</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口</span></span><br><span class="line">  entry: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">  <span class="comment">// 出口</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// path 文件输出目录，必须是绝对路径</span></span><br><span class="line">    <span class="comment">// path.resolve() 返回一个绝对路径</span></span><br><span class="line">    <span class="comment">// __dirname 当前文件所在绝对路径</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">    filename: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 加载器</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 插件</span></span><br><span class="line">  plugins: [],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  mode: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>运行 <code>npx webpack</code>进行打包</li>
</ol>
<h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><ul>
<li>主要做两件事<ol>
<li>编译代码，使浏览器能识别运行<ul>
<li>样式</li>
<li>字体</li>
<li>图片</li>
<li>html</li>
</ul>
</li>
<li>代码质量检查，设置代码规范<ul>
<li>提前检查代码隐患，使代码更健壮</li>
<li>统一团队编码风格</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="处理样式资源"><a href="#处理样式资源" class="headerlink" title="处理样式资源"></a>处理样式资源</h3><ol>
<li><p>css</p>
<ul>
<li><p>下载两个 loader <code>npm i css-loader style-loader -D</code></p>
</li>
<li><p>配置 module</p>
<ul>
<li><pre><code class="javascript">module: &#123;
        rules: [
            &#123;
                test: /\.css$/,
                use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ]
            &#125;
        ],
    &#125;,
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">     - ![image-<span class="number">20220606201544356</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220606201544356</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. less</span><br><span class="line"></span><br><span class="line">   - 下载 less loader `npm i less-loader -D`</span><br><span class="line"></span><br><span class="line">   - 配置 module</span><br><span class="line"></span><br><span class="line">     - ```javascript</span><br><span class="line">       &#123;</span><br><span class="line">               test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">               use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">             &#125;,</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>use 中的 loader 是从后往前执行，因此 less-loader 需要放在 style-loader 与 css-loader 之后</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>sass/scss</p>
<ul>
<li><p>下载 sass-loader <code>npm i sass-loader sass -D</code></p>
</li>
<li><p>配置 module</p>
<ul>
<li><pre><code class="javascript">&#123;
        test: /\.s[ac]ss$/,
        use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;],
      &#125;,
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">4</span>. styl</span><br><span class="line"></span><br><span class="line">   - 下载 stylus-loader `npm i stylus-loader -D`</span><br><span class="line"></span><br><span class="line">   - 配置 module</span><br><span class="line"></span><br><span class="line">     - ```javascript</span><br><span class="line">       &#123;</span><br><span class="line"><span class="title">               test:</span> /\.styl$/,</span><br><span class="line"><span class="title">               use:</span> [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">             &#125;,</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="处理图片资源"><a href="#处理图片资源" class="headerlink" title="处理图片资源"></a>处理图片资源</h3><ol>
<li><p>webpack5 已经内置了 file-loader 和 url-loader 两个 loader</p>
</li>
<li><p>只需要在 module 中进行配置即可</p>
<ul>
<li><pre><code class="javascript">&#123;
        test: /\.(png|jpe?g|gif|webp)$/,
        type: &quot;asset&quot;,
      &#125;,
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 优化图片资源</span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> 将小于某大小的图片转换为 data url （base64）</span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> 优点：减少请求数量</span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> 缺点：体积变大</span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">```javascript</span></span><br><span class="line"><span class="code">     parser: &#123;</span></span><br><span class="line"><span class="code">       dataUrlCondition: &#123;</span></span><br><span class="line"><span class="code">         maxSize: 10 * 1024; // 小于10kb的图片会被base64处理</span></span><br><span class="line"><span class="code">       &#125;</span></span><br><span class="line"><span class="code">     &#125;</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="修改输出资源的名称和路径"><a href="#修改输出资源的名称和路径" class="headerlink" title="修改输出资源的名称和路径"></a>修改输出资源的名称和路径</h3><ol>
<li><p>修改 js 文件路径</p>
<ul>
<li><code>filename: &quot;static/js/main.js&quot;,</code></li>
<li><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220606224701172.png" alt="image-20220606224701172"></li>
</ul>
</li>
<li><p>修改 html 引入</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220606224741833.png" alt="image-20220606224741833"></li>
</ul>
</li>
<li><p>修改图片输出路径以及命名</p>
<ul>
<li><pre><code class="javascript">generator: &#123;
                    // 将图片文件输出到 static/imgs 目录中
                    // 将图片文件命名 [hash:8][ext][query]
                    // [hash:8]: hash值取8位
                    // [ext]: 使用之前的文件扩展名
                    // [query]: 添加之前的query参数
                    filename: &quot;static/imgs/[hash:8][ext][query]&quot;,
                &#125;,
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   - ![image-<span class="number">20220606224852478</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220606224852478</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 自动清空上次打包资源</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 配置 output</span><br><span class="line">   - `clean: true`</span><br><span class="line">   - ![image-<span class="number">20220606225727622</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220606225727622</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 处理字体图标资源</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 配置 loader</span><br><span class="line"></span><br><span class="line">   - ```javascript</span><br><span class="line">     &#123;</span><br><span class="line">                     test: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">                     type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">                     generator: &#123;</span><br><span class="line">                         filename: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">                     &#125;,</span><br><span class="line">                 &#125;,</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220606230029205.png" alt="image-20220606230029205"></p>
</li>
</ul>
</li>
</ol>
<h3 id="处理-js-资源"><a href="#处理-js-资源" class="headerlink" title="处理 js 资源"></a>处理 js 资源</h3><ol>
<li><p>处理代码格式，使用 eslint</p>
<ol>
<li><p>在根目录创建 .eslintrc.js 文件</p>
</li>
<li><p>配置 .eslintrc.js 文件</p>
</li>
<li><pre><code class="javascript">module.exports = &#123;
  // 解析选项
  parserOptions: &#123;
    ecmaVersion: 6, // ES 语法版本
    sourceType: &quot;module&quot;, // ES 模块化
    ecmaFeatures: &#123;
      // ES 其他特性
      jsx: true, // 如果是 React 项目，就需要开启 jsx 语法
    &#125;,
  &#125;,
  // 继承其他规则，后期配置react项目可以继承react官方规则
  extends: [&quot;react-app&quot;],
  // 覆盖继承的规则，一个一个手rules写过于复杂
  rules: &#123;
    // 我们的规则会覆盖掉react-app的规则
    semi: &quot;error&quot;, // 禁止使用分号
    &quot;array-callback-return&quot;: &quot;warn&quot;, // 强制数组方法的回调函数中有 return 语句，否则警告
    &quot;default-case&quot;: [
      &quot;warn&quot;, // 要求 switch 语句中有 default 分支，否则警告
      &#123; commentPattern: &quot;^no default$&quot; &#125;, // 允许在最后注释 no default, 就不会有警告了
    ],
    eqeqeq: [
      &quot;warn&quot;, // 强制使用 === 和 !==，否则警告
      &quot;smart&quot;, // https://eslint.bootcss.com/docs/rules/eqeqeq#smart 除了少数情况下不会有警告
    ],
  &#125;,
  // ...
  // 其他规则详见：https://eslint.bootcss.com/docs/user-guide/configuring
&#125;;
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">4.</span> ![<span class="string">image-20220607000245951</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607000245951.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> rules 具体规则</span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">`&quot;off&quot;`</span> 或 <span class="code">`0`</span> - 关闭规则</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`&quot;warn&quot;`</span> 或 <span class="code">`1`</span> - 开启规则，使用警告级别的错误：<span class="code">`warn`</span> (不会导致程序退出)</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`&quot;error&quot;`</span> 或 <span class="code">`2`</span> - 开启规则，使用错误级别的错误：<span class="code">`error`</span> (当被触发的时候，程序会退出)</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> 下载包 <span class="code">`npm i eslint-webpack-plugin eslint -D`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">7.</span> 配置 webpack.config.js 文件</span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">`const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">```javascript</span></span><br><span class="line"><span class="code">     plugins: [</span></span><br><span class="line"><span class="code">         new ESLintWebpackPlugin(&#123;</span></span><br><span class="line"><span class="code">           // 指定检查文件的根目录</span></span><br><span class="line"><span class="code">           context: path.resolve(__dirname, &quot;src&quot;),</span></span><br><span class="line"><span class="code">         &#125;),</span></span><br><span class="line"><span class="code">       ],</span></span><br></pre></td></tr></table></figure>

- ![image-20220607000723823](https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607000723823.png)

- ![image-20220607000745553](https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607000745553.png)</code></pre>
</li>
<li><p>为了更好的开发体验，可以下载 vscode 的 eslint 插件，并且配置 .eslintignore 文件，忽略 dist 文件夹</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607001010979.png" alt="image-20220607001010979"></li>
</ul>
</li>
</ol>
</li>
<li><p>处理兼容性，使用 babel</p>
<ol>
<li><p>在根目录创建 babel.config.js 文件</p>
</li>
<li><p>下载相关包 <code>npm i babel-loader @babel/core @babel/preset-env -D</code></p>
</li>
<li><p>配置 babel.config.js 文件</p>
<ol>
<li><p>presets 预设</p>
<ol>
<li><code>@babel/preset-env</code>: 一个智能预设，允许您使用最新的 JavaScript。</li>
<li><code>@babel/preset-react</code>：一个用来编译 React jsx 语法的预设</li>
<li><code>@babel/preset-typescript</code>：一个用来编译 TypeScript 语法的预设</li>
</ol>
</li>
<li><pre><code class="javascript">module.exports = &#123;
  // 预设
  presets: [&quot;@babel/preset-env&quot;],
&#125;;
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">4</span>. 配置 webpack.config.js 文件</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. 排除 node_modules 文件夹</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span>. ```javascript</span><br><span class="line">      &#123;</span><br><span class="line">              test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">              exclude: <span class="regexp">/node_modules/</span>, <span class="regexp">//</span> 排除node_modules代码不编译</span><br><span class="line">              loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="处理-Html-资源"><a href="#处理-Html-资源" class="headerlink" title="处理 Html 资源"></a>处理 Html 资源</h3><ol>
<li><p>安装插件 <code>npm i html-webpack-plugin -D</code></p>
</li>
<li><p>配置 web pack.config.js 文件</p>
<ol>
<li><p><code>const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);</code></p>
</li>
<li><pre><code class="javascript">new HtmlWebpackPlugin(&#123;
      // 以 public/index.html 为模板创建文件
      // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源
      template: path.resolve(__dirname, &quot;public/index.html&quot;),
    &#125;),
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">3</span>. 打包后的 html 会自动引入 js 文件，因此 index.html 中不需要手动引入了</span><br><span class="line"><span class="number">4</span>. ![image-<span class="number">20220607150650273</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607150650273</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 开发服务器 &amp; 自动化</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 下载包 `npm i webpack-dev-server -D`</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 配置 webpack.config.js 文件</span><br><span class="line"></span><br><span class="line">   - ```javascript</span><br><span class="line">     <span class="regexp">//</span> 开发服务器</span><br><span class="line">       devServer: &#123;</span><br><span class="line">         host: <span class="string">&quot;localhost&quot;</span>, <span class="regexp">//</span> 启动服务器域名</span><br><span class="line">         port: <span class="string">&quot;3000&quot;</span>, <span class="regexp">//</span> 启动服务器端口号</span><br><span class="line">         open: true, <span class="regexp">//</span> 是否自动打开浏览器</span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ol>
</li>
<li><p>当启用开发服务器后，所有代码都在内存中编译打包，因此并不会输出到 dist 目录下</p>
</li>
</ol>
<h2 id="生产模式"><a href="#生产模式" class="headerlink" title="生产模式"></a>生产模式</h2><ul>
<li><p>优化代码运行性能</p>
</li>
<li><p>优化代码打包速度</p>
</li>
</ul>
<ol>
<li><p>分别配置开发环境与生产环境文件，存入 config 文件夹</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607154900222.png"></li>
<li>因为存入了 config 文件夹，因此需要修改 webpack 配置文件中的路径</li>
</ul>
</li>
<li><p>配置 package.json 简化命令</p>
<ul>
<li><pre><code class="json">  // 其他省略
  &quot;scripts&quot;: &#123;
    &quot;start&quot;: &quot;npm run dev&quot;,
    &quot;dev&quot;: &quot;npx webpack serve --config ./config/webpack.dev.js&quot;,
    &quot;build&quot;: &quot;npx webpack --config ./config/webpack.prod.js&quot;
  &#125;
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   - ![image-<span class="number">20220607155141887</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607155141887</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">### css 处理</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 目前 css 文件被打包到 js 文件中，当 js 文件加载时，会创建 style 标签来生成样式</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 网速慢的时候会产生屏闪现象</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 应该将 css 文件单独出来，用 link 标签加载，性能更好</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. 配置 webpack 文件</span><br><span class="line"></span><br><span class="line">   - `const MiniCssExtractPlugin = require(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);`</span><br><span class="line"></span><br><span class="line">   - 替换所有的 style-loader</span><br><span class="line"></span><br><span class="line">   - ![image-<span class="number">20220607155949418</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607155949418</span>.png)</span><br><span class="line"></span><br><span class="line">   - 提取 css 成单独文件</span><br><span class="line"></span><br><span class="line">     - ```javascript</span><br><span class="line">       <span class="regexp">//</span> 提取css成单独文件</span><br><span class="line">           new MiniCssExtractPlugin(&#123;</span><br><span class="line">             <span class="regexp">//</span> 定义输出文件名和目录</span><br><span class="line">             filename: <span class="string">&quot;static/css/main.css&quot;</span>,</span><br><span class="line">           &#125;),</span><br></pre></td></tr></table></figure>

- ![image-20220607160048147](https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607160048147.png)</code></pre>
</li>
</ul>
</li>
<li><p>css 兼容性处理</p>
<ol>
<li><p>下载包 <code>npm i postcss-loader postcss postcss-preset-env -D</code></p>
</li>
<li><p>配置 webpack 文件</p>
<ul>
<li><p>在 css-loader 之后添加配置</p>
</li>
<li><pre><code class="javascript">&#123;
            loader: &quot;postcss-loader&quot;,
            options: &#123;
              postcssOptions: &#123;
                plugins: [
                  &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题
                ],
              &#125;,
            &#125;,
          &#125;,
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   - ![image-<span class="number">20220607160452201</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607160452201</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 控制兼容性</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. 在 package.json 中配置 browserslist</span><br><span class="line"></span><br><span class="line">      - 兼容到 ie8</span><br><span class="line"></span><br><span class="line">        - ```json</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="regexp">//</span> 其他省略</span><br><span class="line">            <span class="string">&quot;browserslist&quot;</span>: [<span class="string">&quot;ie &gt;= 8&quot;</span>]</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

 - 不考虑旧版本浏览器

   - ```json
     &#123;
       // 其他省略
       &quot;browserslist&quot;: [&quot;last 2 version&quot;, &quot;&gt; 1%&quot;, &quot;not dead&quot;]
     &#125;
     <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">      -</span> ![<span class="string">image-20220607161009633</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607161009633.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> css 压缩</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> 下载插件包 <span class="code">`npm i css-minimizer-webpack-plugin -D`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   2.</span> 配置 webpack 文件</span><br><span class="line"></span><br><span class="line"><span class="bullet">      1.</span> <span class="code">`const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">      2.</span> <span class="code">```javascript</span></span><br><span class="line"><span class="code">         // css压缩</span></span><br><span class="line"><span class="code">             new CssMinimizerPlugin(),</span></span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>html 压缩</p>
<ol>
<li>默认生产模式已经开启了：html 压缩和 js 压缩</li>
<li>不需要额外进行配置</li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack高级优化</title>
    <url>/2021/06/16/Webpack%E9%AB%98%E7%BA%A7%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Webpack-高级优化"><a href="#Webpack-高级优化" class="headerlink" title="Webpack 高级优化"></a>Webpack 高级优化</h1><h2 id="提升开发体验"><a href="#提升开发体验" class="headerlink" title="提升开发体验"></a>提升开发体验</h2><h3 id="sourcemap"><a href="#sourcemap" class="headerlink" title="sourcemap"></a>sourcemap</h3><ol>
<li><p>打包完后的代码不便与阅读</p>
</li>
<li><p>因此需要 sourcemap 来生成源代码与构建后代码的一一映射</p>
</li>
<li><p>会生成 xxx.map 文件，包含源代码与构建后代码每一行，每一列的映射关系</p>
<ol>
<li>如果构建代码出错，通过 xxx.map 文件可以定位到源代码出错位置</li>
</ol>
</li>
</ol>
<span id="more"></span>

<ol start="4">
<li><p>使用</p>
<ol>
<li><p>开发模式</p>
<ol>
<li><p><code>cheap-module-source-map</code></p>
<ul>
<li><p>优点：打包编译快，只含行映射</p>
</li>
<li><p>缺点：没有列映射</p>
</li>
<li><pre><code class="javascript">module.exports = &#123;
  // 其他省略
  mode: &quot;development&quot;,
  devtool: &quot;cheap-module-source-map&quot;,
&#125;;
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2</span>. 生产模式</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. `source-map`</span><br><span class="line"></span><br><span class="line">      - 优点：包含行/列映射 （生产模式打包后的代码时是压缩为一行的，没有列映射很难定位出错位置）</span><br><span class="line"></span><br><span class="line">      - 缺点：打包编译速度更慢</span><br><span class="line"></span><br><span class="line">      - ```javascript</span><br><span class="line">        module.exports = &#123;</span><br><span class="line">          // 其他省略</span><br><span class="line"><span class="title">          mode:</span> <span class="string">&quot;production&quot;</span>,</span><br><span class="line"><span class="title">          devtool:</span> <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">        &#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="提升打包构建速度"><a href="#提升打包构建速度" class="headerlink" title="提升打包构建速度"></a>提升打包构建速度</h2><h4 id="HotModuleReplacement"><a href="#HotModuleReplacement" class="headerlink" title="HotModuleReplacement"></a>HotModuleReplacement</h4><ol>
<li><p>开发过程中，我们修改了一个模块的代码，webpack 默认将所有模块重新编译打包，速度很慢</p>
<ul>
<li>因此我们只需要对修改的模块重新编译打包，其他模块不变就可以提升打包速度</li>
</ul>
</li>
<li><p>HotModuleReplacement（HMR/热模块替换）：在程序运行中，替换、添加或删除模块，而无需重新加载整个页面</p>
</li>
<li><p>配置</p>
<ol>
<li><pre><code class="javascript">module.exports = &#123;
  // 其他省略
  devServer: &#123;
    host: &quot;localhost&quot;, // 启动服务器域名
    port: &quot;3000&quot;, // 启动服务器端口号
    open: true, // 是否自动打开浏览器
    hot: true, // 开启HMR功能（只能用于开发环境，生产环境不需要了）
  &#125;,
&#125;;
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="number">2</span>. 可以在 js 中判断是否支持 hmr，但是会非常麻烦</span><br><span class="line"></span><br><span class="line">      - ![image-<span class="number">20220607180103928</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607180103928</span>.png)</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span>. 实际开发过程中用 loader 来解决</span><br><span class="line"></span><br><span class="line">      - React-hot-loader</span><br><span class="line"></span><br><span class="line"><span class="comment">### OneOf</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 打包过程中，每个文件会经过所有 loader 处理，虽然正则没有匹配上，但是都需要经过一遍，浪费时间</span><br><span class="line"><span class="number">2</span>. 使用 oneof：只要有一个匹配上了就不进行多余操作</span><br><span class="line"><span class="number">3</span>. 配置 webpack</span><br><span class="line">   - ![image-<span class="number">20220607182231155</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607182231155</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Include/Exclude</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 开发过程中我们需要使用第三方库或者插件，这些文件都会下载到 node_module 文件夹中</span><br><span class="line">   - 这些文件是不需要编译就可以使用的</span><br><span class="line">   - 因此我们在编译 js 的时候要排除 node_module</span><br><span class="line"><span class="number">2</span>. 配置 webpack</span><br><span class="line">   <span class="number">1</span>. ![image-<span class="number">20220607182501230</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607182501230</span>.png)</span><br><span class="line">   <span class="number">2</span>. ![image-<span class="number">20220607182527569</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607182527569</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Cache</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 每次打包都需要经过 Eslint 检查以及 babel 编译，速度慢</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 我们可以缓存 eslint 检查和 babel 的编译结果，这样在第二次打包的速度就更快了</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 配置 webpack （缓存文件不要压缩，可以提高检索效率）</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. ```javascript</span><br><span class="line">      options: &#123;</span><br><span class="line">                    cacheDirectory: true, <span class="regexp">//</span> 开启babel编译缓存</span><br><span class="line">                    cacheCompression: false, <span class="regexp">//</span> 缓存文件不要压缩</span><br><span class="line">                  &#125;,</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><pre><code class="javascript">cache: true, // 开启缓存
      // 缓存目录
      cacheLocation: path.resolve(
        __dirname,
        &quot;../node_modules/.cache/.eslintcache&quot;
      ),
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="number">3</span>. ![image-<span class="number">20220607182755181</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607182755181</span>.png)</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span>. ![image-<span class="number">20220607182839166</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607182839166</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Thread</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 项目越庞大，打包速度越慢</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 对 js 文件的处理主要是 eslint，babel，terser 三个工具，所以我们要提升他们的速度</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 开启多进程同时处理 js</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. 配置 webpack</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. 获取 cpu 的核数</span><br><span class="line"></span><br><span class="line">      - ```javascript</span><br><span class="line">        <span class="regexp">//</span> nodejs核心模块，直接使用</span><br><span class="line">        const os = require(<span class="string">&quot;os&quot;</span>);</span><br><span class="line">        <span class="regexp">//</span> cpu核数</span><br><span class="line">        const threads = os.cpus().length;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>下载包 <code>npm i thread-loader -D</code></p>
</li>
<li><pre><code class="javascript">use: [
              &#123;
                loader: &quot;thread-loader&quot;, // 开启多进程
                options: &#123;
                  workers: threads, // 数量
                &#125;,
              &#125;,
              &#123;
                loader: &quot;babel-loader&quot;,
                options: &#123;
                  cacheDirectory: true, // 开启babel编译缓存
                &#125;,
              &#125;,
            ],
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">   4.</span> ![<span class="string">image-20220607193846738</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607193846738.png</span>)</span><br><span class="line"><span class="bullet">   5.</span> ![<span class="string">image-20220607193819516</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607193819516.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">   6.</span> ![<span class="string">image-20220607193928589</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607193928589.png</span>)</span><br><span class="line"><span class="bullet">   7.</span> 项目较小的时候开多线程打包速度反而变慢，因为开启线程也是耗时操作，因此只有项目到达一定大小的时候开启多线程才能提高打包速度</span><br><span class="line"></span><br><span class="line"><span class="section">## 减少代码体积</span></span><br><span class="line"></span><br><span class="line"><span class="section">### Tree Shaking</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 开发过程中我们定义了一些工具函数库，或者使用了第三方的工具库或者组件库</span><br><span class="line"><span class="bullet">   -</span> 如果没有特殊处理，当我们只使用了一小部分功能时，打包却要引入整个库，这无疑会增大打包后的体积</span><br><span class="line"><span class="bullet">2.</span> tree shaking 是个术语，用于描述移除 js 中没有使用上的代码</span><br><span class="line"><span class="bullet">   -</span> 依赖于 es module</span><br><span class="line"><span class="bullet">3.</span> webpack 默认开启该功能，无需其他配置</span><br><span class="line"></span><br><span class="line"><span class="section">### Babel</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> babel 在编译时为每个文件都插入了辅助代码，使代码体积过大</span><br><span class="line"><span class="bullet">2.</span> 可以将这些辅助代码作为一个独立的模块，避免重复引入</span><br><span class="line"><span class="bullet">3.</span> 配置 webpack</span><br><span class="line"><span class="bullet">   1.</span> 下载包 <span class="code">`npm i @babel/plugin-transform-runtime -D`</span></span><br><span class="line"><span class="bullet">   2.</span> <span class="code">`@babel/plugin-transform-runtime`</span>可以禁用 babel 的自动引入</span><br><span class="line"><span class="bullet">   3.</span> ![<span class="string">image-20220607195613506</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607195613506.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### Image Minimizer</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果项目中有很多图片，那么打包后图片体积会很大，请求速度会慢</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 因此需要对图片进行压缩，减少图片体积</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 配置 webpack</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> 下载包 <span class="code">`npm i image-minimizer-webpack-plugin imagemin -D`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">      1.</span> 无损压缩</span><br><span class="line"><span class="bullet">         -</span> <span class="code">`npm install imagemin-gifsicle imagemin-jpegtran imagemin-optipng imagemin-svgo -D`</span></span><br><span class="line"><span class="bullet">      2.</span> 有损压缩</span><br><span class="line"><span class="bullet">         -</span> <span class="code">`npm install imagemin-gifsicle imagemin-mozjpeg imagemin-pngquant imagemin-svgo -D`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   2.</span> <span class="code">```javascript</span></span><br><span class="line"><span class="code">      const ImageMinimizerPlugin = require(&quot;image-minimizer-webpack-plugin&quot;);</span></span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><pre><code class="javascript">// 压缩图片
      new ImageMinimizerPlugin(&#123;
        minimizer: &#123;
          implementation: ImageMinimizerPlugin.imageminGenerate,
          options: &#123;
            plugins: [
              [&quot;gifsicle&quot;, &#123; interlaced: true &#125;],
              [&quot;jpegtran&quot;, &#123; progressive: true &#125;],
              [&quot;optipng&quot;, &#123; optimizationLevel: 5 &#125;],
              [
                &quot;svgo&quot;,
                &#123;
                  plugins: [
                    &quot;preset-default&quot;,
                    &quot;prefixIds&quot;,
                    &#123;
                      name: &quot;sortAttrs&quot;,
                      params: &#123;
                        xmlnsOrder: &quot;alphabetical&quot;,
                      &#125;,
                    &#125;,
                  ],
                &#125;,
              ],
            ],
          &#125;,
        &#125;,
      &#125;),
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="number">4</span>. ![image-<span class="number">20220607200319039</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607200319039</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 优化代码性能</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Code split</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 打包代码会把所有代码打包到一个文件中，体积太大</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. 如果我们只需要渲染首页，就应该只加载首页的 js 文件</span><br><span class="line">   <span class="number">2</span>. 所以我们在打包的时候对文件进行代码分割，生成多个 js 文件，渲染哪个页面就只加载某个 js 文件</span><br><span class="line">   <span class="number">3</span>. 这样加载的资源少，速度就快</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. code split 主要做两件事</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. 分割文件：将打包生成的文件进行分割，生成多个 js 文件</span><br><span class="line">   <span class="number">2</span>. 按需加载：需要哪个文件就加载哪个文件</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 多入口</span><br><span class="line"></span><br><span class="line">   - 多个入口文件</span><br><span class="line">   - ![image-<span class="number">20220607202046597</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607202046597</span>.png)</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. 下载包 `npm i webpack webpack-cli html-webpack-plugin -D`</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span>. 配置 webpack</span><br><span class="line"></span><br><span class="line">      - ```javascript</span><br><span class="line">        <span class="regexp">//</span> webpack.config.js</span><br><span class="line">        const path = require(<span class="string">&quot;path&quot;</span>);</span><br><span class="line">        const HtmlWebpackPlugin = require(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line">        module.exports = &#123;</span><br><span class="line">          <span class="regexp">//</span> 单入口</span><br><span class="line">          <span class="regexp">//</span> entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">          <span class="regexp">//</span> 多入口</span><br><span class="line">          entry: &#123;</span><br><span class="line">            main: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">            app: <span class="string">&quot;./src/app.js&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          output: &#123;</span><br><span class="line">            path: path.resolve(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">            <span class="regexp">//</span> [name]是webpack命名规则，使用chunk的name作为输出的文件名。</span><br><span class="line">            <span class="regexp">//</span> 什么是chunk？打包的资源就是chunk，输出出去叫bundle。</span><br><span class="line">            <span class="regexp">//</span> chunk的name是啥呢？ 比如： entry中xxx: <span class="string">&quot;./src/xxx.js&quot;</span>, name就是xxx。注意是前面的xxx，和文件名无关。</span><br><span class="line">            <span class="regexp">//</span> 为什么需要这样命名呢？如果还是之前写法main.js，那么打包生成两个js文件都会叫做main.js会发生覆盖。(实际上会直接报错的)</span><br><span class="line">            filename: <span class="string">&quot;js/[name].js&quot;</span>,</span><br><span class="line">            clear: true,</span><br><span class="line">          &#125;,</span><br><span class="line">          plugins: [</span><br><span class="line">            new HtmlWebpackPlugin(&#123;</span><br><span class="line">              template: <span class="string">&quot;./public/index.html&quot;</span>,</span><br><span class="line">            &#125;),</span><br><span class="line">          ],</span><br><span class="line">          mode: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

- ```javascript
    optimization: &#123;
      // 代码分割配置
      splitChunks: &#123;
        chunks: &quot;all&quot;, // 对所有模块都进行分割
        // 以下是默认值
        // minSize: 20000, // 分割代码最小的大小
        // minRemainingSize: 0, // 类似于minSize，最后确保提取的文件大小不能为0
        // minChunks: 1, // 至少被引用的次数，满足条件才会代码分割
        // maxAsyncRequests: 30, // 按需加载时并行加载的文件的最大数量
        // maxInitialRequests: 30, // 入口js文件最大并行请求数量
        // enforceSizeThreshold: 50000, // 超过50kb一定会单独打包（此时会忽略minRemainingSize、maxAsyncRequests、maxInitialRequests）
        // cacheGroups: &#123; // 组，哪些模块要打包到一个组
        //   defaultVendors: &#123; // 组名
        //     test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块
        //     priority: -10, // 权重（越大越高）
        //     reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块
        //   &#125;,
        //   default: &#123; // 其他没有写的配置会使用上面的默认值
        //     minChunks: 2, // 这里的minChunks权重更大
        //     priority: -20,
        //     reuseExistingChunk: true,
        //   &#125;,
        // &#125;,
        // 修改配置
        cacheGroups: &#123;
          // 组，哪些模块要打包到一个组
          // defaultVendors: &#123; // 组名
          //   test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块
          //   priority: -10, // 权重（越大越高）
          //   reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块
          // &#125;,
          default: &#123;
            // 其他没有写的配置会使用上面的默认值
            minSize: 0, // 我们定义的文件体积太小了，所以要改打包的最小文件体积
            minChunks: 2,
            priority: -20,
            reuseExistingChunk: true,
          &#125;,
        &#125;,
      &#125;,
  <figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">3.</span> 配置按需加载，动态导入</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span> ```<span class="javascript">javascript</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;hello main&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 动态导入 --&gt; 实现按需加载</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 即使只被引用了一次，也会代码分割</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">import</span>(<span class="string">&quot;./math.js&quot;</span>).then(<span class="function">(<span class="params">&#123; sum &#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          alert(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br></pre></td></tr></table></figure>

2. 一旦通过 import 动态导入语法导入模块，模块就被代码分割，同时也能按需加载了</code></pre>
</li>
</ol>
</li>
<li><p>单入口</p>
<ol>
<li><p>单页面应用（spa），只有一个入口（单入口）</p>
</li>
<li><p>配置 webpack</p>
<ol>
<li><pre><code class="javascript">const path = require(&quot;path&quot;);
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);

module.exports = &#123;
  // 单入口
  entry: &quot;./src/main.js&quot;,
  // 多入口
  // entry: &#123;
  //   main: &quot;./src/main.js&quot;,
  //   app: &quot;./src/app.js&quot;,
  // &#125;,
  output: &#123;
    path: path.resolve(__dirname, &quot;./dist&quot;),
    // [name]是webpack命名规则，使用chunk的name作为输出的文件名。
    // 什么是chunk？打包的资源就是chunk，输出出去叫bundle。
    // chunk的name是啥呢？ 比如： entry中xxx: &quot;./src/xxx.js&quot;, name就是xxx。注意是前面的xxx，和文件名无关。
    // 为什么需要这样命名呢？如果还是之前写法main.js，那么打包生成两个js文件都会叫做main.js会发生覆盖。(实际上会直接报错的)
    filename: &quot;js/[name].js&quot;,
    clean: true,
  &#125;,
  plugins: [
    new HtmlWebpackPlugin(&#123;
      template: &quot;./public/index.html&quot;,
    &#125;),
  ],
  mode: &quot;production&quot;,
  optimization: &#123;
    // 代码分割配置
    splitChunks: &#123;
      chunks: &quot;all&quot;, // 对所有模块都进行分割
      // 以下是默认值
      // minSize: 20000, // 分割代码最小的大小
      // minRemainingSize: 0, // 类似于minSize，最后确保提取的文件大小不能为0
      // minChunks: 1, // 至少被引用的次数，满足条件才会代码分割
      // maxAsyncRequests: 30, // 按需加载时并行加载的文件的最大数量
      // maxInitialRequests: 30, // 入口js文件最大并行请求数量
      // enforceSizeThreshold: 50000, // 超过50kb一定会单独打包（此时会忽略minRemainingSize、maxAsyncRequests、maxInitialRequests）
      // cacheGroups: &#123; // 组，哪些模块要打包到一个组
      //   defaultVendors: &#123; // 组名
      //     test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块
      //     priority: -10, // 权重（越大越高）
      //     reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块
      //   &#125;,
      //   default: &#123; // 其他没有写的配置会使用上面的默认值
      //     minChunks: 2, // 这里的minChunks权重更大
      //     priority: -20,
      //     reuseExistingChunk: true,
      //   &#125;,
      // &#125;,
  &#125;,
&#125;;
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2</span>. ```javascript</span><br><span class="line">       <span class="regexp">//</span> 代码分割配置</span><br><span class="line">       splitChunks: &#123;</span><br><span class="line">         chunks: <span class="string">&quot;all&quot;</span>, <span class="regexp">//</span> 对所有模块都进行分割</span><br><span class="line">         <span class="regexp">//</span> 其他内容用默认配置即可</span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>![image-20220607203135751](/Users/xiaotian/Library/Application Support/typora-user-images/image-20220607203135751.png)</p>
</li>
<li><p>给动态导入的文件取名</p>
<ol>
<li><p>修改 main.js</p>
<ul>
<li><pre><code class="javascript">document.getElementById(&quot;btn&quot;).onClick = function () &#123;
  // eslint会对动态导入语法报错，需要修改eslint配置文件
  // webpackChunkName: &quot;math&quot;：这是webpack动态导入模块命名的方式
  // &quot;math&quot;将来就会作为[name]的值显示。
  import(/* webpackChunkName: &quot;math&quot; */ &quot;./js/math.js&quot;).then(
    (&#123; count &#125;) =&gt; &#123;
      console.log(count(2, 1));
    &#125;
  );
&#125;;
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2.</span> 下载包 `npm i eslint-plugin-import -D`</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 配置 eslint</span><br><span class="line"></span><br><span class="line">   - ```javascript</span><br><span class="line">     <span class="comment">// .eslintrc.js</span></span><br><span class="line">     module.exports = &#123;</span><br><span class="line">       <span class="comment">// 继承 Eslint 规则</span></span><br><span class="line"><span class="symbol">       extends:</span> [<span class="string">&quot;eslint:recommended&quot;</span>],</span><br><span class="line"><span class="symbol">       env:</span> &#123;</span><br><span class="line"><span class="symbol">         node:</span> true, <span class="comment">// 启用node中全局变量</span></span><br><span class="line"><span class="symbol">         browser:</span> true, <span class="comment">// 启用浏览器中全局变量</span></span><br><span class="line">       &#125;,</span><br><span class="line"><span class="symbol">       plugins:</span> [<span class="string">&quot;import&quot;</span>], <span class="comment">// 解决动态导入import语法报错问题 --&gt; 实际使用eslint-plugin-import的规则解决的</span></span><br><span class="line"><span class="symbol">       parserOptions:</span> &#123;</span><br><span class="line"><span class="symbol">         ecmaVersion:</span> <span class="number">6</span>,</span><br><span class="line"><span class="symbol">         sourceType:</span> <span class="string">&quot;module&quot;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line"><span class="symbol">       rules:</span> &#123;</span><br><span class="line">         <span class="string">&quot;no-var&quot;</span>: <span class="number">2</span>, <span class="comment">// 不能使用 var 定义变量</span></span><br><span class="line">       &#125;,</span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
<li><p>配置 webpack，统一命名</p>
<ul>
<li><pre><code class="javascript">filename: &quot;static/js/[name].js&quot;, // 入口文件打包输出资源命名方式
    chunkFilename: &quot;static/js/[name].chunk.js&quot;, // 动态导入输出资源命名方式
    assetModuleFilename: &quot;static/media/[name].[hash][ext]&quot;, // 图片、字体等资源命名方式（注意用hash）
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">            -</span> ![<span class="string">image-20220608111206852</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220608111206852.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">            -</span> ![<span class="string">image-20220608111226416</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220608111226416.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### preload/prefetch</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 之前做了代码分割后实现了按需加载（也就是懒加载）</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> 但是速度不够快，比如一个按钮用户点击了才加载资源，如果该资源非常大的话会有明显的卡顿现象</span><br><span class="line"><span class="bullet">   2.</span> 因此我们想在浏览器空闲的时候加载后续需要使用的资源（预加载）</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> <span class="code">`Preload`</span>：告诉浏览器立即加载资源。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> <span class="code">`Prefetch`</span>：告诉浏览器在空闲时才开始加载资源。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> <span class="code">`Preload`</span> 与 <span class="code">`Prefetch`</span> 共同点</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> 只加载资源，并不执行</span><br><span class="line"><span class="bullet">   2.</span> 都有缓存</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> <span class="code">`Preload`</span> 与 <span class="code">`Prefetch`</span> 区别</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> <span class="code">`Preload`</span>加载优先级高，<span class="code">`Prefetch`</span>加载优先级低。</span><br><span class="line"><span class="bullet">   2.</span> <span class="code">`preload`</span>只加载当前页面需要使用的资源，<span class="code">`prefetch`</span>可以加载当前页面需要使用的资源，也可以加载下一个页面需要使用的资源</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> 兼容性比较差，<span class="code">`preload`</span>兼容性要高一点</span><br><span class="line"></span><br><span class="line"><span class="bullet">7.</span> 配置</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> 下载包 <span class="code">`npm i @vue/preload-webpack-plugin -D`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   2.</span> <span class="code">```javascript</span></span><br><span class="line"><span class="code">      // css压缩</span></span><br><span class="line"><span class="code">          // new CssMinimizerPlugin(),</span></span><br><span class="line"><span class="code">          new PreloadWebpackPlugin(&#123;</span></span><br><span class="line"><span class="code">            rel: &quot;preload&quot;, // preload兼容性更好</span></span><br><span class="line"><span class="code">            as: &quot;script&quot;,</span></span><br><span class="line"><span class="code">            // rel: &#x27;prefetch&#x27; // prefetch兼容性更差</span></span><br><span class="line"><span class="code">          &#125;),</span></span><br></pre></td></tr></table></figure></code></pre>
</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220608114848178.png" alt="image-20220608114848178"></p>
</li>
</ol>
</li>
</ol>
<h3 id="network-cache"><a href="#network-cache" class="headerlink" title="network cache"></a>network cache</h3><ol>
<li><p>对静态资源使用缓存来优化，浏览器再二次请求直接读取缓存，速度更快</p>
</li>
<li><p>回出现一个问题：前后输出的文件名都是一样的，发布新版本浏览器会读取缓存，不会加载新资源</p>
<ol>
<li>我们要从文件名入手，确保更新后的文件名与之前不一样</li>
</ol>
</li>
<li><p>使用 hash</p>
<ul>
<li><p>fullhash（webpack4 是 hash）每次修改任何一个文件，所有文件名的 hash 至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效。</p>
</li>
<li><p>chunkhash 根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。我们 js 和 css 是同一个引入，会共享一个 hash 值。</p>
</li>
<li><p>contenthash 根据文件内容生成 hash 值，只有文件内容变化了，hash 值才会变化。所有文件 hash 值是独享且不同的。</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220608120638753.png" alt="image-20220608120638753"></p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220608120658005.png" alt="image-20220608120658005"></p>
</li>
</ul>
</li>
<li><p>出现问题：只修改了一个文件，但是 main.js 的 hash 也发生了变化，缓存失效</p>
<ol>
<li><p>原因：引用的文件发生变化，导致 main.js 的 content 也发生了变化，最终 main.js 生成新的 hash，是我们不希望看到的</p>
</li>
<li><p>解决</p>
<ol>
<li><p>将 hash 值单独保存在 runtime 文件中</p>
</li>
<li><p>runtime 文件只保存文件的 hash 值和它们与文件关系，整个文件体积就比较小，所以变化重新请求的代价也小。</p>
</li>
<li><pre><code class="javascript">    // 提取runtime文件
    runtimeChunk: &#123;
      name: (entrypoint) =&gt; `runtime~$&#123;entrypoint.name&#125;`, // runtime文件命名规则
    &#125;,
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">### core-js</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> babel 已经对 js 代码进行了一定的兼容性处理，我们使用 @babel/preset-env 智能预设来处理兼容性</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> 但是 es6 有些语法并没有编译转换，比如箭头函数，promise， async 等</span><br><span class="line"><span class="bullet">   2.</span> 所以还是存在一定的兼容性问题，遇到低版本浏览器可能出现报错</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> <span class="code">`core-js`</span> 是专门用来做 ES6 以及以上 API 的 <span class="code">`polyfill`</span>。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 配置 webpack</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> 下载包 <span class="code">`npm i @babel/eslint-parser -D`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   2.</span> 下载包 <span class="code">`npm i core-js`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   3.</span> 可以手动全部引入和手动按需引入（体积大/麻烦）</span><br><span class="line"></span><br><span class="line"><span class="bullet">      1.</span> <span class="code">```javascript</span></span><br><span class="line"><span class="code">         import &quot;core-js&quot;;</span></span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><pre><code class="javascript">import &quot;core-js/es/promise&quot;;
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">4.</span> 配置自动按需引入</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span> 配置 babel.<span class="built_in">config</span>.js</span><br><span class="line"></span><br><span class="line">   <span class="number">2.</span> ```javascript</span><br><span class="line">      <span class="keyword">module</span>.exports = &#123;</span><br><span class="line">        <span class="comment">// 智能预设：能够编译ES6语法</span></span><br><span class="line">        presets: [</span><br><span class="line">          [</span><br><span class="line">            <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">            <span class="comment">// 按需加载core-js的polyfill</span></span><br><span class="line">            &#123;</span><br><span class="line">              useBuiltIns: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">              corejs: &#123; version: <span class="string">&quot;3&quot;</span>, proposals: <span class="literal">true</span> &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          ],</span><br><span class="line">        ],</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="pwa"><a href="#pwa" class="headerlink" title="pwa"></a>pwa</h3><ol>
<li><p>希望提供离线服务</p>
</li>
<li><p>配置 webpack</p>
<ol>
<li><p>下载包 <code>npm i workbox-webpack-plugin -D</code></p>
</li>
<li><p>修改 webpack.config.js</p>
<ol>
<li><pre><code class="javascript">const WorkboxPlugin = require(&quot;workbox-webpack-plugin&quot;);
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">```javascript</span></span><br><span class="line">   <span class="string">new</span> <span class="string">WorkboxPlugin.GenerateSW(&#123;</span></span><br><span class="line">         <span class="string">//</span> <span class="string">这些选项帮助快速启用</span> <span class="string">ServiceWorkers</span></span><br><span class="line">         <span class="string">//</span> <span class="string">不允许遗留任何“旧的”</span> <span class="string">ServiceWorkers</span></span><br><span class="line">         <span class="attr">clientsClaim:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">         <span class="attr">skipWaiting:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">       <span class="string">&#125;),</span></span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220608122751327.png" alt="image-20220608122751327"></p>
</li>
</ol>
</li>
<li><p>修改 main.js</p>
<ul>
<li><pre><code class="javascript">if (&quot;serviceWorker&quot; in navigator) &#123;
  window.addEventListener(&quot;load&quot;, () =&gt; &#123;
    navigator.serviceWorker
      .register(&quot;/service-worker.js&quot;)
      .then((registration) =&gt; &#123;
        console.log(&quot;SW registered: &quot;, registration);
      &#125;)
      .catch((registrationError) =&gt; &#123;
        console.log(&quot;SW registration failed: &quot;, registrationError);
      &#125;);
  &#125;);
&#125;</code></pre>
</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Webpack</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
</search>
