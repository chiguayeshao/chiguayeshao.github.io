<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SunleDog</title>
  
  <subtitle>SunleDog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-03T15:32:56.748Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Xiaotian Ye</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 路由</title>
    <link href="http://example.com/2022/06/25/React%20%E8%B7%AF%E7%94%B1/"/>
    <id>http://example.com/2022/06/25/React%20%E8%B7%AF%E7%94%B1/</id>
    <published>2022-06-25T02:17:42.000Z</published>
    <updated>2022-08-03T15:32:56.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-路由"><a href="#React-路由" class="headerlink" title="React 路由"></a>React 路由</h1><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>React-Router 支持我们使用 HashRouter 和 BrowserRouter 两种路由规则，react-router-dom 提供了 BrowserRouter 和 HashRouter 两个组件来实现应用的 ui 和 url 同步</p><p>BrowserRouter 创建的 url 格式 <a href="http://xxx.com/path">http://xxx.com/path</a></p><p>HashRouter 创建的 url 格式 <a href="http://xxx.com/#/path">http://xxx.com/#/path</a></p><span id="more"></span><h3 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h3><p>他是由 HTML5 提供的 history api 来保持 ui 和 url 同步的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter</span><br><span class="line">  basename=&#123;string&#125;</span><br><span class="line">  forceRefresh=&#123;bool&#125;</span><br><span class="line">  getUserConfirmation=&#123;func&#125;</span><br><span class="line">  keyLength=&#123;number&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>其中的参数如下：</p><p>bansename 所有的路由的基准 url，basename 的正确格式是前面有一个斜杠，但是尾部不能有斜杠</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter basename=<span class="string">&quot;/calendar&quot;</span>&gt;</span><br><span class="line">  &lt;Link to=<span class="string">&quot;/today&quot;</span> /&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/calendar/today&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>forceRefresh 如果为 true，在导航过程中页面将会刷新一下，一般情况下只有在不支持 html5 history api 的浏览器中使用此功能</li><li>getUserConfirmation 用于确认导航的函数，默认使用 window.confirm。例如当从/a 导航到/b 的时候，会默认使用 confirm 函数弹出一个提示，用户点击确定后才进行导航，否则不做任何处理。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是默认的确认函数</span></span><br><span class="line"><span class="keyword">const</span> getConfirmation = <span class="function">(<span class="params">message, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> allowTransition = <span class="built_in">window</span>.confirm(message);</span><br><span class="line">  callback(allowTransition);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;BrowserRouter getUserConfirmation=&#123;getConfirmation&#125; /&gt;;</span><br></pre></td></tr></table></figure><ul><li>keylength 用来设置 location.key 的长度</li></ul><h3 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h3><p>使用 url 的 hash 部分（window.loaction.hash）来保持 ui 和 url 的同步。由此可以看出，HashRouter 是通过 url 的 hash 属性来控制路由跳转的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;HashRouter basename=&#123;string&#125; getUserConfirmation=&#123;func&#125; hashType=&#123;string&#125; /&gt;</span><br></pre></td></tr></table></figure><p>其中的参数如下：</p><ul><li>basename,getuserconfirmation 和 BrowserRouter 功能一样</li><li>hashType.window.loaction.hash 使用的 hash 诶西，有如下几种<ul><li>slash - 后面跟一个斜杠，例如#/和#/sunshine/fuck</li><li>noslash - 后面没有斜杠，例如#和#sunshine/fuck</li><li>hashbang - 谷歌风格的 ajax crawlable ，例如#! 和#!/sunshine/fuck</li></ul></li></ul><h2 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h2><p>react-router 的工作方式是在组件树的顶层放一个 Router 组件，然后在组件树中散落着很多 Route 组件，顶层 Router 组件负责分析监听 url 的变化而 Route 组件可以直接读取这些信息。Router 与 Route 配合，Router 是“提供者”，Route 是“消费者”</p><h3 id="Route-的基本使用"><a href="#Route-的基本使用" class="headerlink" title="Route 的基本使用"></a>Route 的基本使用</h3><p>Route 是 React Route 用于配制路由信息的组件，也是 React Router 中使用频率最高的组件。每当一个组件需要根据 url 决定是否渲染时，就需要创建一个 Route</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route exact=&#123;bool&#125; path=&#123;string&#125; component=&#123;Component&#125; /&gt;</span><br></pre></td></tr></table></figure><p>其中的属性如下：</p><ul><li>exact：当 url 完全匹配时，值为 true，否则为 false，它控制匹配 / 路径时是否向下继续匹配</li><li>path：构建嵌套路由时会使用到，每个 Route 都需要定一个 path 属性</li><li>component：表示路径对应显示的组件</li></ul><p>url 匹配到 Route 时，Route 会创建一个 match 对象作为 props 中的一个属性传递给被渲染的组件。这个对象包含以下四个属性</p><ul><li>params：Route 的 path 可以包含参数，params 就是用于从匹配到的 url 中解析出 path 中的参数</li><li>isExact：同 Route 的 exact</li><li>path：同 Route 的 path</li><li>url：url 的匹配方式</li></ul><h3 id="Route-渲染组件的方式"><a href="#Route-渲染组件的方式" class="headerlink" title="Route 渲染组件的方式"></a>Route 渲染组件的方式</h3><ol><li><p>component 属性</p><p>component 属性的值是一个组件，当 URL 和 Route 匹配时，component 属性定义的组件就会被渲染</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&#x27;/foo&#x27;</span> component=&#123;Foo&#125; &gt;</span><br></pre></td></tr></table></figure><p>当 url 为/foo 的时候 Foo 组件被渲染</p><ol start="2"><li><p>render（多用于权限验证）</p><p>render 的值是一个函数，他返回一个 React 元素，这种方式方便的为待渲染的组件传递额外的属性</p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route</span><br><span class="line">  path=<span class="string">&quot;/foo&quot;</span></span><br><span class="line">  render=&#123;<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    &lt;Foo &#123;...props&#125; data=&#123;extraProps&#125; /&gt;;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>Foo 组件接收到了额外的 data 属性</p><p>采用 render 方式渲染时，组件是否渲染不仅要看路径是否匹配，还要由 render 属性所接受的函数来共同决定。注意，此时 render 函数会接受一个参数 props，即当前 Route 组件的 props 对象。</p><ol start="3"><li><p>children（多用于菜单）</p><p>children 的值也是一个函数，函数返回要渲染的 React 元素。与前两种方式的不同之处是，无论是否匹配成功，children 返回的组件都会被渲染。但是当匹配不成功的时候，match 属性为 null</p></li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route</span><br><span class="line">  path=<span class="string">&quot;/foo&quot;</span></span><br><span class="line">  render=&#123;<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    &lt;div className=&#123;props.match ? <span class="string">&quot;active&quot;</span> : <span class="string">&quot;&quot;</span>&#125;&gt;</span><br><span class="line">      &lt;Foo &#123;...props&#125; data=&#123;extraProps&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>如果 Route 匹配当前 URL，待渲染的元素的根节点 div 的 class 将设置成 active。</p><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>switch 通常用来包裹 Route，用来渲染路径匹配的第一个<code>&lt;Route&gt;</code>或<code>&lt;Redirect&gt;</code>，他里面不能放其他元素</p><p>例如不加<code>&lt;Switch&gt;</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Route &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;Route path=<span class="string">&quot;/&quot;</span> component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">&lt;Route path=<span class="string">&quot;/login&quot;</span> component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>Route 组件的 path 属性用于匹配路径，因为我们需要匹配/到 Home，匹配/login 到 Login，所以需要两个 Route，但是，我们不能这么写。这么写的话，当 url 的 path 为/login 的时候，会同时匹配到/和/login，因此页面会显示 Home 和 Login 两个组件，这个时候就需要 switch 来做到只展示一个匹配组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Switch, Route &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/&quot;</span> component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/login&quot;</span> component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class="line">&lt;/Switch&gt;;</span><br></pre></td></tr></table></figure><p>此时，再访问/login 的时候，却只显示了 Home 组件。这个时候就需要用到 exact 属性了，他的作用就是精确匹配路径，经常与 switch 联合使用，只有当 url 和该 route 的 path 属性完全一致的时候才能匹配上</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Switch, Route &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=<span class="string">&quot;/&quot;</span> component=&#123;Home&#125;&gt;&lt;/Route&gt;</span><br><span class="line">  &lt;Route exact path=<span class="string">&quot;/login&quot;</span> component=&#123;Login&#125;&gt;&lt;/Route&gt;</span><br><span class="line">&lt;/Switch&gt;;</span><br></pre></td></tr></table></figure><h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><p>在单页面应用中，往往需要在不同页面直接进行切换，这就使用到了 link 组件，link 组件为我们提供了一个声明式的，可访问的导航链接</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line">&lt;Link to=<span class="string">&quot;/login&quot;</span>&gt;Login&lt;<span class="regexp">/Link&gt;; /</span><span class="regexp">/ 会被解析成：&lt;a href=&quot;/</span>login<span class="string">&quot;&gt;Login&lt;/a&gt;</span></span><br></pre></td></tr></table></figure><ul><li>to：string ｜ object：声明要导航到的链接地址，可以是一个字符串，也可以是一个对象</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Link &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串形式</span></span><br><span class="line">&lt;Link to=<span class="string">&quot;/login?name=zhangsan#hash&quot;</span>&gt;Login&lt;/Link&gt;</span><br><span class="line"><span class="comment">// 对象形式</span></span><br><span class="line">&lt;Link to=<span class="string">&quot;&#123;&#123;</span></span><br><span class="line"><span class="string">  pathname:&#x27;/login&#x27;,        // 要导航到的路径</span></span><br><span class="line"><span class="string">  search: &#x27;?name=zhangsan&#x27;, // 查询参数</span></span><br><span class="line"><span class="string">  hash: &#x27;#hash&#x27;             // 哈希</span></span><br><span class="line"><span class="string">&#125;&#125;&quot;</span>&gt;Login&lt;/Link&gt;</span><br></pre></td></tr></table></figure><ul><li>Replace:boolean：该属性决定是将点击后的链接替换历史堆栈中的最新消息，设置为 true 的时候是替换，设置为 false 的时候是添加。默认为 false</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">&quot;/login&quot;</span> replace&gt;</span><br><span class="line">  Login</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure><h2 id="navlink"><a href="#navlink" class="headerlink" title="navlink"></a>navlink</h2><p>navlink 是特殊的 link，可以与当前 url 匹配的 link 元素添加样式属性。</p><ul><li>activeclassname：string 表示当前元素处于激活状态时的类名，默认为 active</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line">&lt;NavLink to=<span class="string">&quot;/login&quot;</span> activeClassName=<span class="string">&quot;active&quot;</span>&gt;</span><br><span class="line">  Login</span><br><span class="line">&lt;/NavLink&gt;;</span><br></pre></td></tr></table></figure><ul><li>activestyle：object 表示当前元素处于激活状态时的样式</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line">&lt;NavLink to=<span class="string">&quot;/login&quot;</span> activeStyle=&#123;&#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span> &#125;&#125;&gt;</span><br><span class="line">  Login</span><br><span class="line">&lt;/NavLink&gt;;</span><br></pre></td></tr></table></figure><ul><li>exact：boolean 设置为 true 时，当且仅当完全匹配时才应用 activeclassname 和 activestyle</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line">&lt;NavLink exact to=<span class="string">&quot;/login&quot;</span>&gt;</span><br><span class="line">  Login</span><br><span class="line">&lt;/NavLink&gt;;</span><br></pre></td></tr></table></figure><ul><li>isactive：function 可以通过 isactive 添加一些额外的逻辑来决定当前链接是否处于激活状态</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line">dealActive () &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&lt;NavLink to=<span class="string">&quot;/login&quot;</span> isActive=&#123;dealActive&#125;&gt;Login&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure><h2 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h2><p>路由重定向：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Redirect <span class="keyword">from</span>=<span class="string">&quot;/users/:id&quot;</span> to=<span class="string">&quot;/users/profile/:id&quot;</span> /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/users/profile/:id&quot;</span> component=&#123;Profile&#125; /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><p>当请求/user/：id 被重定向去 /user/profile/:id</p><ul><li>属性 from：string：需要匹配的将要被重定向路径</li><li>属性 to：string：重定向的 url 字符串</li><li>属性 to：object：重定向的 loaction 对象</li><li>数据 push：bool：若为真，重定向操作会把新地址加入到历史访问记录里面，并且无法回退到前面的页面</li></ul><h2 id="Promt"><a href="#Promt" class="headerlink" title="Promt"></a>Promt</h2><p>当用户离开当前页面做出一些提示，属性如下</p><ul><li>属性 message：string 当用户离开当前页面时，设置的提示信息</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Prompt message=<span class="string">&quot;确定要离开？&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><ul><li>属性 message：func 当用户离开页面时，设置回调函数</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Prompt message=&#123;<span class="function">(<span class="params">location</span>) =&gt;</span> <span class="string">`确定要去 <span class="subst">$&#123;location.pathname&#125;</span> ?`</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><ul><li>属性 when：bool 决定是否启用 Prompt</li></ul><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>嵌套路由是指在 Route 渲染的组件内部定义新的 Route，比如上面的 login 组件中可以再定义两个路由</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Login = (&#123;match&#125; =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="comment">// 这里 match.url 等于 /login</span></span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Route path=&#123;<span class="string">`<span class="subst">$&#123;match.url&#125;</span>/:id`</span>&#125; component=&#123;TestId&#125; /&gt;</span><br><span class="line">            &lt;Route exact path=&#123;match.url&#125; component=&#123;Test&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：嵌套路由是基于当前路由创建的路由，前缀是我们当前的路由</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>假设，再增加一个新的页面叫 Product，对应路径为/produc，但是只有用户登录了之后才显示。如果用静态路由，我们在渲染之前就确定了这条路由规则，这样即使用户没有登录，也可以访问 product，我们还不得不在 product 组件中做用户是否登录的检查</p><p>如果用动态路由，则只需要在代码中的一处涉及这个逻辑:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">      &lt;Route exact path=<span class="string">&#x27;/&#x27;</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        isUserLogin() &amp;&amp;</span><br><span class="line">        &lt;Route exact path=<span class="string">&#x27;/product&#x27;</span> component=&#123;Product&#125;/&gt;,</span><br><span class="line">      &#125;</span><br><span class="line">      &lt;Route path=<span class="string">&#x27;/about&#x27;</span> component=&#123;About&#125;/&gt;</span><br><span class="line"> &lt;/Switch&gt;</span><br></pre></td></tr></table></figure><p>可以用任何条件决定 Route 组件是否渲染，比如可以根据页面的宽度，设备的类型来决定路由规则，动态路由就有了最大的自由度</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;React-路由&quot;&gt;&lt;a href=&quot;#React-路由&quot; class=&quot;headerlink&quot; title=&quot;React 路由&quot;&gt;&lt;/a&gt;React 路由&lt;/h1&gt;&lt;h2 id=&quot;路由器&quot;&gt;&lt;a href=&quot;#路由器&quot; class=&quot;headerlink&quot; title=&quot;路由器&quot;&gt;&lt;/a&gt;路由器&lt;/h2&gt;&lt;p&gt;React-Router 支持我们使用 HashRouter 和 BrowserRouter 两种路由规则，react-router-dom 提供了 BrowserRouter 和 HashRouter 两个组件来实现应用的 ui 和 url 同步&lt;/p&gt;
&lt;p&gt;BrowserRouter 创建的 url 格式 &lt;a href=&quot;http://xxx.com/path&quot;&gt;http://xxx.com/path&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HashRouter 创建的 url 格式 &lt;a href=&quot;http://xxx.com/#/path&quot;&gt;http://xxx.com/#/path&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 组件通信03</title>
    <link href="http://example.com/2022/06/24/React%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A103/"/>
    <id>http://example.com/2022/06/24/React%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A103/</id>
    <published>2022-06-24T12:27:42.000Z</published>
    <updated>2022-08-02T08:11:48.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-组件通信-03"><a href="#React-组件通信-03" class="headerlink" title="React 组件通信 03"></a>React 组件通信 03</h1><h2 id="非嵌套组件通信"><a href="#非嵌套组件通信" class="headerlink" title="非嵌套组件通信"></a>非嵌套组件通信</h2><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><p>开发过程中会遇到这样一个场景 FirstChild 和 SecondChild 是我们的两个组件，FirstChild 组件 dispatch action，在 SecondChild 组件展示变化的数据，那么就需要在两个字组件之上一层来设计 context</p><ol><li>首先建立 context，存储一个初始状态和一个变更 state 的状态管理器</li></ol><span id="more"></span><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  value: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;ADD&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">value</span>: state.value + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;REDUCE&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">value</span>: state.value - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>需要显性的声明 Context.Provider 把数据传给包裹组件，这就需要使用 useReducer，我们把 reducer 和默认 state 作为 useReducer 的参数传入</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Content.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; useReducer, createContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> FirstChild <span class="keyword">from</span> <span class="string">&quot;./FirstChild&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> SecondChild <span class="keyword">from</span> <span class="string">&quot;./SecondChild&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; reducer, defaultState &#125; <span class="keyword">from</span> <span class="string">&quot;./Context&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Context = createContext(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Content</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, defaultState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Context.Provider value=&#123;&#123; state, <span class="attr">dispatch</span>: dispatch &#125;&#125;&gt;</span><br><span class="line">      &lt;FirstChild /&gt;</span><br><span class="line">      &lt;SecondChild /&gt;</span><br><span class="line">    &lt;/Context.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>组件 FirstChild 有两个按钮‘ADD’和‘REDUCE’，点击两个按钮分别进行加 1 减 1 操作</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Context &#125; <span class="keyword">from</span> <span class="string">&quot;./Content&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FirstChild</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> AppContext = useContext(Context);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          AppContext.dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;ADD&quot;</span> &#125;);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        ADD</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          AppContext.dispatch(&#123; <span class="attr">type</span>: <span class="string">&quot;REDUCE&quot;</span> &#125;);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        REDUCE</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> FirstChild;</span><br></pre></td></tr></table></figure><ol start="4"><li>组件 SecondChild 展示当前 state.value</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Context &#125; <span class="keyword">from</span> <span class="string">&quot;./Content&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SecondChild</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> AppContext = useContext(Context);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;AppContext.state.value&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> SecondChild;</span><br></pre></td></tr></table></figure><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><p>Redux 是一个独立的事件通讯插件，Redux 的基本原理实际上就是围绕着 store 进行的，这个 store 是通过 createStore()方法创建的，他具有唯一性，可以认为是整个应用的数据存储中心，集中了大部分页面需要的状态数据。想要改变 state 的唯一方法就是出发 Action，Reducer 接收到 Action 并更新数据 store。按照这个思想，Redux 适用于多交互，多数据源的场景。</p><h3 id="订阅发布模式"><a href="#订阅发布模式" class="headerlink" title="订阅发布模式"></a>订阅发布模式</h3><p>前文讲过订阅发布模式 [设计模式 订阅发布 | SunleDog](<a href="https://sunle.dog/2022/02/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">https://sunle.dog/2022/02/03/设计模式</a> 订阅发布/)</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;React-组件通信-03&quot;&gt;&lt;a href=&quot;#React-组件通信-03&quot; class=&quot;headerlink&quot; title=&quot;React 组件通信 03&quot;&gt;&lt;/a&gt;React 组件通信 03&lt;/h1&gt;&lt;h2 id=&quot;非嵌套组件通信&quot;&gt;&lt;a href=&quot;#非嵌套组件通信&quot; class=&quot;headerlink&quot; title=&quot;非嵌套组件通信&quot;&gt;&lt;/a&gt;非嵌套组件通信&lt;/h2&gt;&lt;h3 id=&quot;Hooks&quot;&gt;&lt;a href=&quot;#Hooks&quot; class=&quot;headerlink&quot; title=&quot;Hooks&quot;&gt;&lt;/a&gt;Hooks&lt;/h3&gt;&lt;p&gt;开发过程中会遇到这样一个场景 FirstChild 和 SecondChild 是我们的两个组件，FirstChild 组件 dispatch action，在 SecondChild 组件展示变化的数据，那么就需要在两个字组件之上一层来设计 context&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先建立 context，存储一个初始状态和一个变更 state 的状态管理器&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 组件通信02</title>
    <link href="http://example.com/2022/06/24/React%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A102/"/>
    <id>http://example.com/2022/06/24/React%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A102/</id>
    <published>2022-06-24T09:37:42.000Z</published>
    <updated>2022-08-02T04:26:04.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-组件通信-02"><a href="#React-组件通信-02" class="headerlink" title="React 组件通信 02"></a>React 组件通信 02</h1><h2 id="跨级组件通信"><a href="#跨级组件通信" class="headerlink" title="跨级组件通信"></a>跨级组件通信</h2><p>跨级组件通信就是父组件与子组件的子组件或者更深层次的通信。我们可以让父组件传给子组件，再让子组件传递给他的子组件，一次逐级传递。但是这种传递方式当层级关系超过两层的时候会过于臃肿，不好维护。Contex 通过组件树提供了一个传递数据的方法，从而避免在每个层级之间手动传递 props 属性。</p><p>祖先代码示例：</p><span id="more"></span><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>; <span class="comment">// 用于属性校验，想了解更多见文末的扩展阅读。</span></span><br><span class="line"><span class="keyword">import</span> Sub <span class="keyword">from</span> <span class="string">&quot;./Sub.js&quot;</span>; <span class="comment">// 中间组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在父组件定义上下文（Context）</span></span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    <span class="comment">// 声明静态属性 必须要写</span></span><br><span class="line">    color: PropTypes.string, <span class="comment">// PropTypes 用于校验属性类型</span></span><br><span class="line">    callback: PropTypes.func, <span class="comment">// 回调函数</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 用于返回上下文（Context）的值便于后代获取</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      color: <span class="string">&quot;pink&quot;</span>,</span><br><span class="line">      callback: <span class="built_in">this</span>.callback.bind(<span class="built_in">this</span>), <span class="comment">// 需要绑定this</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">callback</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    alert(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Sub</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间组件代码示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> SubSub <span class="keyword">from</span> <span class="string">&quot;./SubSub.js&quot;</span>; <span class="comment">// 后代组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SubSub</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后代组件代码示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>; <span class="comment">// 用于属性校验，想了解更多见文末的扩展阅读。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">SubSub</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    <span class="comment">// 后代组件必须校验属性类型</span></span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">    callback: PropTypes.func,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> style = &#123; <span class="attr">color</span>: <span class="built_in">this</span>.context.color &#125;; <span class="comment">// 通过 this.context 获取上下文的值</span></span><br><span class="line">    <span class="keyword">const</span> cb = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context.callback(msg);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;style&#125;&gt;</span><br><span class="line">        &lt;h1&gt;In SubSub.js&lt;<span class="regexp">/h1&gt; /</span><span class="regexp">/ 粉色字体展示 In SubSub.js</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;cb(&quot;this is SubSub.js&quot;)&#125;&gt;click me&lt;/</span>button&gt; <span class="comment">// 点击按钮，弹出</span></span><br><span class="line">        <span class="built_in">this</span> is SubSub.js 字样</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上可以看出，祖先组件声明了 context 上下文，后代组件通过 this.context 获取祖先组件传递下来的内容</p><p><strong>注意：</strong>如果后代组件使用构造函数 Constructor，那么 context 需要作为构造函数的第二个参数传入，否则无法使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">constructor</span> (<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;React-组件通信-02&quot;&gt;&lt;a href=&quot;#React-组件通信-02&quot; class=&quot;headerlink&quot; title=&quot;React 组件通信 02&quot;&gt;&lt;/a&gt;React 组件通信 02&lt;/h1&gt;&lt;h2 id=&quot;跨级组件通信&quot;&gt;&lt;a href=&quot;#跨级组件通信&quot; class=&quot;headerlink&quot; title=&quot;跨级组件通信&quot;&gt;&lt;/a&gt;跨级组件通信&lt;/h2&gt;&lt;p&gt;跨级组件通信就是父组件与子组件的子组件或者更深层次的通信。我们可以让父组件传给子组件，再让子组件传递给他的子组件，一次逐级传递。但是这种传递方式当层级关系超过两层的时候会过于臃肿，不好维护。Contex 通过组件树提供了一个传递数据的方法，从而避免在每个层级之间手动传递 props 属性。&lt;/p&gt;
&lt;p&gt;祖先代码示例：&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 组件通信01</title>
    <link href="http://example.com/2022/06/24/React%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A101/"/>
    <id>http://example.com/2022/06/24/React%20%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A101/</id>
    <published>2022-06-24T05:57:42.000Z</published>
    <updated>2022-08-02T03:51:45.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-组件通信-01"><a href="#React-组件通信-01" class="headerlink" title="React 组件通信 01"></a>React 组件通信 01</h1><p>组件之间是存在嵌套关系的，如果我们将一个程序的所有逻辑都放在一个组件中。那么这个组件将会变得臃肿不堪并且难以维护，所以组件化的思想就是对组件进行拆分，再将这些组件嵌套在一起，最终形成应用程序。</p><p>如图：</p><ul><li>app 组件是 Header Main Footer 组件的父组件</li><li>Main 组件是 Banner ProductList 组件的父组件</li></ul><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220802110311983.png" alt="image-20220802110311983"></p><p>在开发过程中就涉及到了组件之间的通信：父子组件通信，兄弟组件通信，祖孙组件通信等等。</p><h2 id="父传子通信"><a href="#父传子通信" class="headerlink" title="父传子通信"></a>父传子通信</h2><p>父子组件之间的通信是通过 props 来完成的</p><p>代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildCpn</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, age, height &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;name + age + height&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;ChildCpn name=<span class="string">&quot;zhangsan&quot;</span> age=<span class="string">&quot;18&quot;</span> height=<span class="string">&quot;1.88&quot;</span> /&gt;</span><br><span class="line">        &lt;ChildCpn name=<span class="string">&quot;lisi&quot;</span> age=<span class="string">&quot;20&quot;</span> height=<span class="string">&quot;1.98&quot;</span> /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性验证：</p><p>对于传递给子组件的数据，有时候我们可能希望进行数据格式验证</p><ul><li>typescript</li><li>prop-type 库</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步：引入prop-types 库</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二部：设置数据的类型</span></span><br><span class="line">ChildCpn.propTypes = &#123;</span><br><span class="line">  name: PropTypes.string,</span><br><span class="line">  age: PropTypes.nimber,</span><br><span class="line">  height: PropTypes.number,</span><br><span class="line">  names: PropTypes.array,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对数据进行验证时，如果数据类型不符，则会报错</p><p>如果父组件什么都没传递，我们可以给数据设置默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ChildCpn.defaultProps = &#123;</span><br><span class="line">  name: <span class="string">&quot;React&quot;</span>,</span><br><span class="line">  age: <span class="number">30</span>,</span><br><span class="line">  height: <span class="number">1.88</span>,</span><br><span class="line">  names: [<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="子传父通信"><a href="#子传父通信" class="headerlink" title="子传父通信"></a>子传父通信</h2><p>只要让父组件给子组件传递一个绑定了自身上下文的回调函数，那么在子组件中调用这个函数的时候，就可以将想要交给父组件的数据以函数参数的形式传递出去，这样就形成了从子组件到父组件的流动</p><p>具体步骤</p><ol><li>父组件将回调函数通过 props 传递给子组件</li><li>子组件把父组件需要的数据作为回调函数的参数传递</li><li>子组件调用该回调函数</li></ol><p>简单的计数器案例：</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220802114339870.png" alt="image-20220802114339870"></p><p>代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CounterButton = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; handleClick &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;+<span class="number">1</span>&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Counter = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [counter, setCounter] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> increment = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setCounter(counter + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h2&gt;current count:&#123;counter&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;CounterButton handleClick=&#123;increment&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter;</span><br></pre></td></tr></table></figure><p>在父组件中定义了 increment 方法，当点击子组件按钮的时候就会触发父组件的方法，并执行该方法，实现数据加一</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;React-组件通信-01&quot;&gt;&lt;a href=&quot;#React-组件通信-01&quot; class=&quot;headerlink&quot; title=&quot;React 组件通信 01&quot;&gt;&lt;/a&gt;React 组件通信 01&lt;/h1&gt;&lt;p&gt;组件之间是存在嵌套关系的，如果我们将一个程序的所有逻辑都放在一个组件中。那么这个组件将会变得臃肿不堪并且难以维护，所以组件化的思想就是对组件进行拆分，再将这些组件嵌套在一起，最终形成应用程序。&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;app 组件是 Header Main Footer 组件的父组件&lt;/li&gt;
&lt;li&gt;Main 组件是 Banner ProductList 组件的父组件&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 应用SOLID原则04</title>
    <link href="http://example.com/2022/06/23/React%20%E5%BA%94%E7%94%A8SOLID%E5%8E%9F%E5%88%9904/"/>
    <id>http://example.com/2022/06/23/React%20%E5%BA%94%E7%94%A8SOLID%E5%8E%9F%E5%88%9904/</id>
    <published>2022-06-23T07:18:29.000Z</published>
    <updated>2022-08-01T13:47:36.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-应用-SOLID-原则-04"><a href="#React-应用-SOLID-原则-04" class="headerlink" title="React 应用 SOLID 原则 04"></a>React 应用 SOLID 原则 04</h1><p>定义：依赖倒置原则指出<strong>“要依赖于抽象，不要依赖于具体”</strong>。换句话说一个组件不应该依赖于另一个组件，而是他们应该依赖于一些共同的抽象。这里“组件”是指应用程序的任何部分，可以是 React 组件，函数，模块或第三方库。</p><span id="more"></span><p>代码演示：</p><p>有一个 LoginForm 组件，他在提交表单时将用户凭据发生到某些 API</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">&quot;~/common/api&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LoginForm = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [email, setEmail] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [password, setPassword] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleSubmit = <span class="keyword">async</span> (evt) =&gt; &#123;</span><br><span class="line">    evt.preventDefault();</span><br><span class="line">    <span class="keyword">await</span> api.login(email, password);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;handleSubmit&#125;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">&quot;email&quot;</span></span><br><span class="line">        value=&#123;email&#125;</span><br><span class="line">        onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> setEmail(e.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">&quot;password&quot;</span></span><br><span class="line">        value=&#123;password&#125;</span><br><span class="line">        onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> setPassword(e.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;Log <span class="keyword">in</span>&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这段代码中，LoginForm 组件直接引用了 api 模块，因此他们直接存在紧密耦合。这种依赖关系会导致一个组件的更改会影响其他组件。依赖倒置原则就是提倡打破这种耦合。</p><p>如何优化：</p><p>首先从 LoginForm 中删除对 api 模块的直接引用，允许通过 props 传入所需回调函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">type Props = &#123;</span><br><span class="line">  onSubmit: <span class="function">(<span class="params">email: string, password: string</span>) =&gt;</span> <span class="built_in">Promise</span>&lt;<span class="keyword">void</span>&gt;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LoginForm = <span class="function">(<span class="params">&#123; onSubmit &#125;: Props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [email, setEmail] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [password, setPassword] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleSubmit = <span class="keyword">async</span> (evt) =&gt; &#123;</span><br><span class="line">    evt.preventDefault();</span><br><span class="line">    <span class="keyword">await</span> onSubmit(email, password);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;handleSubmit&#125;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">&quot;email&quot;</span></span><br><span class="line">        value=&#123;email&#125;</span><br><span class="line">        onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> setEmail(e.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">&quot;password&quot;</span></span><br><span class="line">        value=&#123;password&#125;</span><br><span class="line">        onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> setPassword(e.target.value)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;button type=<span class="string">&quot;submit&quot;</span>&gt;Log <span class="keyword">in</span>&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过这样修改，LoginFrom 组件不再依赖于 api 模块，向 api 提交凭证的逻辑是通过 onsubmit 毁掉函数抽象出来，现在由父组件负责提供该逻辑的具体实现。</p><p>为此创建一个 ConnectedLoginForm 组件来将表单提交逻辑委托给 api 模块</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> api <span class="keyword">from</span> <span class="string">&quot;~/common/api&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ConnectedLoginForm = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> handleSubmit = <span class="keyword">async</span> (email, password) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> api.login(email, password);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">LoginForm</span> <span class="attr">onSubmit</span>=<span class="string">&#123;handleSubmit&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ConnectedLoginForm 组件充当 api 和 LoginForm 之间的粘合剂，而他们本身保持完全独立，这样就可以对这两个组件进行单独的修改和维护，而不必担心修改会影响其他组件。</p><p>依赖倒置原则就是为了最小化应用程序不同组件之间的耦合。</p><p>总结：</p><p>应用 SOLID 原则使我们的 React 代码更易于维护和健壮，但需要注意的是，过分遵循这些原则可能会造成破坏并导致代码过度设计。因此我们需要学会识别对组件进一步分解或解耦在什么时候会导致复杂度上升而没有带来任何好处。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;React-应用-SOLID-原则-04&quot;&gt;&lt;a href=&quot;#React-应用-SOLID-原则-04&quot; class=&quot;headerlink&quot; title=&quot;React 应用 SOLID 原则 04&quot;&gt;&lt;/a&gt;React 应用 SOLID 原则 04&lt;/h1&gt;&lt;p&gt;定义：依赖倒置原则指出&lt;strong&gt;“要依赖于抽象，不要依赖于具体”&lt;/strong&gt;。换句话说一个组件不应该依赖于另一个组件，而是他们应该依赖于一些共同的抽象。这里“组件”是指应用程序的任何部分，可以是 React 组件，函数，模块或第三方库。&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 应用SOLID原则03</title>
    <link href="http://example.com/2022/06/23/React%20%E5%BA%94%E7%94%A8SOLID%E5%8E%9F%E5%88%9903/"/>
    <id>http://example.com/2022/06/23/React%20%E5%BA%94%E7%94%A8SOLID%E5%8E%9F%E5%88%9903/</id>
    <published>2022-06-23T02:28:18.000Z</published>
    <updated>2022-08-01T13:25:59.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-应用-SOLID-原则-03"><a href="#React-应用-SOLID-原则-03" class="headerlink" title="React 应用 SOLID 原则 03"></a>React 应用 SOLID 原则 03</h1><h2 id="里氏替换原则（LSP）"><a href="#里氏替换原则（LSP）" class="headerlink" title="里氏替换原则（LSP）"></a>里氏替换原则（LSP）</h2><p>里氏替换原则可以理解为<strong>对象之间的一种关系，子类型对象可以替换为超类型对象</strong>。这个原则严重依赖类继承来定义超类型和子类型关系，但它在 React 中可能不太适用，因为我们几乎不会处理类，更不用说类继承了。虽然远离类继承会不可避免地将这一原则转变为完全不同的东西，但使用继承编写 React 代码会使代码变得糟糕（<strong>React 团队不推荐使用继承</strong>）。因此，对于这一原则不在过多解释。</p><h2 id="接口隔离原则（ISP）"><a href="#接口隔离原则（ISP）" class="headerlink" title="接口隔离原则（ISP）"></a>接口隔离原则（ISP）</h2><p>定义：<strong>客户端不应该依赖它不需要的接口</strong></p><span id="more"></span><p>代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type Video = &#123;</span><br><span class="line">  title: string</span><br><span class="line">  duration: number</span><br><span class="line">  coverUrl: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Props = &#123;</span><br><span class="line">  items: <span class="built_in">Array</span>&lt;Video&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VideoList = <span class="function">(<span class="params">&#123; items &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;items.map(<span class="function"><span class="params">item</span> =&gt;</span></span><br><span class="line">        &lt;Thumbnail</span><br><span class="line">          key=&#123;item.title&#125;</span><br><span class="line">          video=&#123;item&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Thumbnail 组件的实现</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Props = &#123;</span><br><span class="line">  video: Video,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Thumbnail = <span class="function">(<span class="params">&#123; video &#125;: Props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;video.coverUrl&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Thumbnail 这个组件非常简单，但它有一个问题，他希望将完整的视频对象作为 props 传入，但是仅有效的使用其属性之一（coverUrl）</p><p>除了视频，我们还需要渲染直播的缩略图，这两种媒体资源会混合在同一个列表中</p><p>定义直播类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LiveStream = &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  previewUrl: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更新 VideoList 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type Props = &#123;</span><br><span class="line">  items: <span class="built_in">Array</span>&lt;Video | LiveStream&gt;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VideoList = <span class="function">(<span class="params">&#123; items &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;items.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;coverUrl&quot;</span> <span class="keyword">in</span> item) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Thumbnail</span> <span class="attr">video</span>=<span class="string">&#123;item&#125;</span> /&gt;</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 直播组件，该怎么写？</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这时候就发现了一个问题，我们可以轻松区分视频和直播对象，但是不能将后者传递给 Thumbnail 组件，因为 video 和 liveStream 类型不兼容。他们包含了不同的属性来保存缩略图。视频对象调用 coverUrl，直播对象调用 previewUrl。这就使组件依赖了比实际更多的 props 的原因所在。</p><p>下面来重构 Thumbnail</p><p>代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type Props = &#123;</span><br><span class="line">  items: <span class="built_in">Array</span>&lt;Video | LiveStream&gt;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VideoList = <span class="function">(<span class="params">&#123; items &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;items.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;coverUrl&quot;</span> <span class="keyword">in</span> item) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Thumbnail</span> <span class="attr">coverUrl</span>=<span class="string">&#123;item.coverUrl&#125;</span> /&gt;</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Thumbnail</span> <span class="attr">coverUrl</span>=<span class="string">&#123;item.previewUrl&#125;</span> /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接口隔离主张最小化系统组件直接的依赖关系，使他们的耦合度降低，从而提高可复用性。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;React-应用-SOLID-原则-03&quot;&gt;&lt;a href=&quot;#React-应用-SOLID-原则-03&quot; class=&quot;headerlink&quot; title=&quot;React 应用 SOLID 原则 03&quot;&gt;&lt;/a&gt;React 应用 SOLID 原则 03&lt;/h1&gt;&lt;h2 id=&quot;里氏替换原则（LSP）&quot;&gt;&lt;a href=&quot;#里氏替换原则（LSP）&quot; class=&quot;headerlink&quot; title=&quot;里氏替换原则（LSP）&quot;&gt;&lt;/a&gt;里氏替换原则（LSP）&lt;/h2&gt;&lt;p&gt;里氏替换原则可以理解为&lt;strong&gt;对象之间的一种关系，子类型对象可以替换为超类型对象&lt;/strong&gt;。这个原则严重依赖类继承来定义超类型和子类型关系，但它在 React 中可能不太适用，因为我们几乎不会处理类，更不用说类继承了。虽然远离类继承会不可避免地将这一原则转变为完全不同的东西，但使用继承编写 React 代码会使代码变得糟糕（&lt;strong&gt;React 团队不推荐使用继承&lt;/strong&gt;）。因此，对于这一原则不在过多解释。&lt;/p&gt;
&lt;h2 id=&quot;接口隔离原则（ISP）&quot;&gt;&lt;a href=&quot;#接口隔离原则（ISP）&quot; class=&quot;headerlink&quot; title=&quot;接口隔离原则（ISP）&quot;&gt;&lt;/a&gt;接口隔离原则（ISP）&lt;/h2&gt;&lt;p&gt;定义：&lt;strong&gt;客户端不应该依赖它不需要的接口&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 应用SOLID原则02</title>
    <link href="http://example.com/2022/06/22/React%20%E5%BA%94%E7%94%A8SOLID%E5%8E%9F%E5%88%9902/"/>
    <id>http://example.com/2022/06/22/React%20%E5%BA%94%E7%94%A8SOLID%E5%8E%9F%E5%88%9902/</id>
    <published>2022-06-22T11:20:08.000Z</published>
    <updated>2022-08-01T13:09:16.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-应用-SOLID-原则-02"><a href="#React-应用-SOLID-原则-02" class="headerlink" title="React 应用 SOLID 原则 02"></a>React 应用 SOLID 原则 02</h1><h2 id="开放封闭原则（OCP）"><a href="#开放封闭原则（OCP）" class="headerlink" title="开放封闭原则（OCP）"></a>开放封闭原则（OCP）</h2><p>定义：一个软件实体（类，模块，函数）应该对扩展开放，对修改关闭。主张在不更改源代码的情况下扩展组件的方式来构造组件</p><p>以下代码构建了一个 Header 组件，根据页面不同，Header 组件的 UI 也有些不同</p><span id="more"></span><p>代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Header = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname &#125; = useRouter();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;header&gt;</span><br><span class="line">      &lt;Logo /&gt;</span><br><span class="line">      &lt;Actions&gt;</span><br><span class="line">        &#123;pathname === <span class="string">&quot;/dashboard&quot;</span> &amp;&amp; (</span><br><span class="line">          &lt;Link to=<span class="string">&quot;/events/new&quot;</span>&gt;Create event&lt;/Link&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">        &#123;pathname === <span class="string">&quot;/&quot;</span> &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/dashboard&quot;</span>&gt;</span>Go to dashboard<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&#125;</span><br><span class="line">      &lt;/Actions&gt;</span><br><span class="line">    &lt;/header&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HomePage = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;Header /&gt;</span><br><span class="line">    &lt;OtherHomeStuff /&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DashboardPage = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;Header /&gt;</span><br><span class="line">    &lt;OtherDashboardStuff /&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>根据所在页面的不同，呈现指向不同页面组件的链接。但是如果将该 Header 组件添加到更多的页面中，每次创建新页面的时候，都需要引用 Header 组件，改变其内部实现。这种方法使 Header 组件与他的上下文紧密耦合，违背了开放封闭原则</p><p>为了解决这个问题，我们可以使用组件组合。Header 组件不需要关系它内部的渲染是什么，相反，它可以将此责任委托给将使用 Children 属性的组件</p><p>代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Header = <span class="function">(<span class="params">&#123; children &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;Logo /&gt;</span><br><span class="line">    &lt;Actions&gt;&#123;children&#125;&lt;/Actions&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HomePage = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;Header&gt;</span><br><span class="line">      &lt;Link to=<span class="string">&quot;/dashboard&quot;</span>&gt;Go to dashboard&lt;/Link&gt;</span><br><span class="line">    &lt;/Header&gt;</span><br><span class="line">    &lt;OtherHomeStuff /&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DashboardPage = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">    &lt;Header&gt;</span><br><span class="line">      &lt;Link to=<span class="string">&quot;/events/new&quot;</span>&gt;Create event&lt;/Link&gt;</span><br><span class="line">    &lt;/Header&gt;</span><br><span class="line">    &lt;OtherDashboardStuff /&gt;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>使用这种方法，我们完全删除了 Header 组件内部的变量逻辑。现在可以使用组合将任何内容放在 Header 中，而无需修改组件本身。</p><p>遵循开放封闭原则可以减少组件之间的耦合，使他更具有可扩展性和可重用性。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;React-应用-SOLID-原则-02&quot;&gt;&lt;a href=&quot;#React-应用-SOLID-原则-02&quot; class=&quot;headerlink&quot; title=&quot;React 应用 SOLID 原则 02&quot;&gt;&lt;/a&gt;React 应用 SOLID 原则 02&lt;/h1&gt;&lt;h2 id=&quot;开放封闭原则（OCP）&quot;&gt;&lt;a href=&quot;#开放封闭原则（OCP）&quot; class=&quot;headerlink&quot; title=&quot;开放封闭原则（OCP）&quot;&gt;&lt;/a&gt;开放封闭原则（OCP）&lt;/h2&gt;&lt;p&gt;定义：一个软件实体（类，模块，函数）应该对扩展开放，对修改关闭。主张在不更改源代码的情况下扩展组件的方式来构造组件&lt;/p&gt;
&lt;p&gt;以下代码构建了一个 Header 组件，根据页面不同，Header 组件的 UI 也有些不同&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React 应用SOLID原则01</title>
    <link href="http://example.com/2022/06/20/React%20%E5%BA%94%E7%94%A8SOLID%E5%8E%9F%E5%88%9901/"/>
    <id>http://example.com/2022/06/20/React%20%E5%BA%94%E7%94%A8SOLID%E5%8E%9F%E5%88%9901/</id>
    <published>2022-06-20T10:40:08.000Z</published>
    <updated>2022-08-01T12:54:10.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-应用-SOLID-原则-01"><a href="#React-应用-SOLID-原则-01" class="headerlink" title="React 应用 SOLID 原则 01"></a>React 应用 SOLID 原则 01</h1><p>在面向对象编程中，SOLID 原则是设计模式的基础，每个字母分别对应如下：</p><ul><li>单一职责原则（SRP）</li><li>开放封闭原则（OCP）</li><li>里氏替换原则（LSP）</li><li>接口隔离原则（ISP）</li><li>依赖倒置原则（DIP）</li></ul><p>下面看一下每个原则在 React 中的应用</p><h2 id="单一职责原则（SRP）"><a href="#单一职责原则（SRP）" class="headerlink" title="单一职责原则（SRP）"></a>单一职责原则（SRP）</h2><p>定义：每个应用应该只有一个职责，也就是只做一件事，可以简单的理解为每个功能/模块/组件都应该只做一件事</p><p>为了确保每个组件只做一件事</p><ul><li>将功能较多的大型组件拆分为较小的组件</li><li>将与功能无关的代码提取到单独的函数中</li><li>将有联系的功能提取到自定义 hooks 中</li></ul><span id="more"></span><p>代码演示：</p><p>显示活跃用户列表的组件</p><p>该组件：获取数据，过滤数据，渲染数据</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ActiveUsersList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [users, setUsers] = useState([]);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> loadUsers = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;/some-api&quot;</span>);</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line">      setUsers(data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    loadUsers();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> weekAgo = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  weekAgo.setDate(weekAgo.getDate() - <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;users</span><br><span class="line">        .filter(<span class="function">(<span class="params">user</span>) =&gt;</span> !user.isBanned &amp;&amp; user.lastActivityAt &gt;= weekAgo)</span><br><span class="line">        .map(<span class="function">(<span class="params">user</span>) =&gt;</span> (</span><br><span class="line">          &lt;li key=&#123;user.id&#125;&gt;</span><br><span class="line">            &lt;img src=&#123;user.avatarUrl&#125; /&gt;</span><br><span class="line">            &lt;p&gt;&#123;user.fullName&#125;&lt;/p&gt;</span><br><span class="line">            &lt;small&gt;&#123;user.role&#125;&lt;/small&gt;</span><br><span class="line">          &lt;/li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同时使用了 useState 和 useEffect，我没可以将他提取到自定义 hook 中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> useUsers = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [users, setUsers] = useState([]);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> loadUsers = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;/some-api&quot;</span>);</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line">      setUsers(data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    loadUsers();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; users &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ActiveUsersList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; users &#125; = useUsers();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> weekAgo = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  weekAgo.setDate(weekAgo.getDate() - <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;users</span><br><span class="line">        .filter(<span class="function">(<span class="params">user</span>) =&gt;</span> !user.isBanned &amp;&amp; user.lastActivityAt &gt;= weekAgo)</span><br><span class="line">        .map(<span class="function">(<span class="params">user</span>) =&gt;</span> (</span><br><span class="line">          &lt;li key=&#123;user.id&#125;&gt;</span><br><span class="line">            &lt;img src=&#123;user.avatarUrl&#125; /&gt;</span><br><span class="line">            &lt;p&gt;&#123;user.fullName&#125;&lt;/p&gt;</span><br><span class="line">            &lt;small&gt;&#123;user.role&#125;&lt;/small&gt;</span><br><span class="line">          &lt;/li&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，useUser hook 只关心一件事：从 api 获取用户，它使我们的组件更具有可读性</p><p>接下来看组件渲染 jsx，我没对对象数组进行遍历，要注意每个数组项生成的 jsx 的复杂性</p><ul><li>如果他是一个没有附加任何事件处理函数的单行代码，那么保持内联</li><li>对于更复杂的 jsx，建议将其提取为单独的组件</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UserItem = <span class="function">(<span class="params">&#123; user &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &lt;img src=&#123;user.avatarUrl&#125; /&gt;</span><br><span class="line">      &lt;p&gt;&#123;user.fullName&#125;&lt;/p&gt;</span><br><span class="line">      &lt;small&gt;&#123;user.role&#125;&lt;/small&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ActiveUsersList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; users &#125; = useUsers();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> weekAgo = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  weekAgo.setDate(weekAgo.getDate() - <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;users</span><br><span class="line">        .filter(<span class="function">(<span class="params">user</span>) =&gt;</span> !user.isBanned &amp;&amp; user.lastActivityAt &gt;= weekAgo)</span><br><span class="line">        .map(<span class="function">(<span class="params">user</span>) =&gt;</span> (</span><br><span class="line">          &lt;UserItem key=&#123;user.id&#125; user=&#123;user&#125; /&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们将用于呈现用户信息的逻辑提取到了单独的组件中，从而我们的组件更小，更可读</p><p>最后对于从 api 获取到的用户列表中所过滤出的非活跃用户的逻辑是相对独立的，可以在其他部分重用，所以可以提取到一个公共函数中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getOnlyActive = <span class="function">(<span class="params">users</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> weekAgo = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  weekAgo.setDate(weekAgo.getDate() - <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> users.filter(</span><br><span class="line">    (user) =&gt; !user.isBanned &amp;&amp; user.lastActivityAt &gt;= weekAgo</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ActiveUsersList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; users &#125; = useUsers();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;getOnlyActive(users).map(<span class="function">(<span class="params">user</span>) =&gt;</span> (</span><br><span class="line">        &lt;UserItem key=&#123;user.id&#125; user=&#123;user&#125; /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上面几个步骤，组件已经变得非常简单，但是还有优化空间。理论上我们只需要获取数据并渲染他，而不需要任何额外的操作，所以可以将 获取数据，过滤数据 这个操作封装到一个新的自定义 hooks 中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="keyword">const</span> useUsers = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [users, setUsers] = useState([]);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> loadUsers = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">&quot;/some-api&quot;</span>);</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> response.json();</span><br><span class="line">      setUsers(data);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    loadUsers();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; users &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列表渲染</span></span><br><span class="line"><span class="keyword">const</span> UserItem = <span class="function">(<span class="params">&#123; user &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">      &lt;img src=&#123;user.avatarUrl&#125; /&gt;</span><br><span class="line">      &lt;p&gt;&#123;user.fullName&#125;&lt;/p&gt;</span><br><span class="line">      &lt;small&gt;&#123;user.role&#125;&lt;/small&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列表过滤</span></span><br><span class="line"><span class="keyword">const</span> getOnlyActive = <span class="function">(<span class="params">users</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> weekAgo = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  weekAgo.setDate(weekAgo.getDate() - <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> users.filter(</span><br><span class="line">    (user) =&gt; !user.isBanned &amp;&amp; user.lastActivityAt &gt;= weekAgo</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useActiveUsers = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; users &#125; = useUsers();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> activeUsers = useMemo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getOnlyActive(users);</span><br><span class="line">  &#125;, [users]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; activeUsers &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ActiveUsersList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; activeUsers &#125; = useActiveUsers();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;activeUsers.map(<span class="function">(<span class="params">user</span>) =&gt;</span> (</span><br><span class="line">        &lt;UserItem key=&#123;user.id&#125; user=&#123;user&#125; /&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里我们创建了 useActiveUsers hook 来处理获取数据和过滤数据，这样组件只做了一件事：渲染他从 hook 中获取的数据</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;React-应用-SOLID-原则-01&quot;&gt;&lt;a href=&quot;#React-应用-SOLID-原则-01&quot; class=&quot;headerlink&quot; title=&quot;React 应用 SOLID 原则 01&quot;&gt;&lt;/a&gt;React 应用 SOLID 原则 01&lt;/h1&gt;&lt;p&gt;在面向对象编程中，SOLID 原则是设计模式的基础，每个字母分别对应如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单一职责原则（SRP）&lt;/li&gt;
&lt;li&gt;开放封闭原则（OCP）&lt;/li&gt;
&lt;li&gt;里氏替换原则（LSP）&lt;/li&gt;
&lt;li&gt;接口隔离原则（ISP）&lt;/li&gt;
&lt;li&gt;依赖倒置原则（DIP）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面看一下每个原则在 React 中的应用&lt;/p&gt;
&lt;h2 id=&quot;单一职责原则（SRP）&quot;&gt;&lt;a href=&quot;#单一职责原则（SRP）&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则（SRP）&quot;&gt;&lt;/a&gt;单一职责原则（SRP）&lt;/h2&gt;&lt;p&gt;定义：每个应用应该只有一个职责，也就是只做一件事，可以简单的理解为每个功能/模块/组件都应该只做一件事&lt;/p&gt;
&lt;p&gt;为了确保每个组件只做一件事&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将功能较多的大型组件拆分为较小的组件&lt;/li&gt;
&lt;li&gt;将与功能无关的代码提取到单独的函数中&lt;/li&gt;
&lt;li&gt;将有联系的功能提取到自定义 hooks 中&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>无障碍化 导航栏与可展开按钮</title>
    <link href="http://example.com/2022/06/15/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%8C%96%20%E5%AF%BC%E8%88%AA%E6%A0%8F%E4%B8%8E%E5%8F%AF%E5%B1%95%E5%BC%80%E6%8C%89%E9%92%AE/"/>
    <id>http://example.com/2022/06/15/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%8C%96%20%E5%AF%BC%E8%88%AA%E6%A0%8F%E4%B8%8E%E5%8F%AF%E5%B1%95%E5%BC%80%E6%8C%89%E9%92%AE/</id>
    <published>2022-06-15T11:11:58.000Z</published>
    <updated>2022-07-31T02:55:05.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无障碍化-导航栏与可展开按钮"><a href="#无障碍化-导航栏与可展开按钮" class="headerlink" title="无障碍化 导航栏与可展开按钮"></a>无障碍化 导航栏与可展开按钮</h1><p>测试工具：</p><ul><li>NVDA screen reader （Free screen reader for Windows）<a href="https://www.nvaccess.org/">NV Access</a></li><li>ChromeVox （Free chrome extension）<a href="https://chrome.google.com/webstore/detail/screen-reader/kgejglhpjiefppelpmljglcjbhoiplfn?hl=en">Screen Reader - Chrome Web Store (google.com)</a></li></ul><p>代码实现：</p><span id="more"></span><ul><li>对于导航栏，添加 nav 标签</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- nav标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/who&quot;</span>&gt;</span>Who am I<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/services&quot;</span>&gt;</span>Services<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;contact&quot;</span>&gt;</span>Contact<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>对于可折叠 button</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可展开按钮 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">aria-expanded</span>=<span class="string">&quot;false&quot;</span> <span class="attr">aria-controls</span>=<span class="string">&quot;sect1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span></span><br><span class="line">      button</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;sect1&quot;</span> <span class="attr">role</span>=<span class="string">&quot;region&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>content<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220731105155702.png" alt="image-20220731105155702"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;无障碍化-导航栏与可展开按钮&quot;&gt;&lt;a href=&quot;#无障碍化-导航栏与可展开按钮&quot; class=&quot;headerlink&quot; title=&quot;无障碍化 导航栏与可展开按钮&quot;&gt;&lt;/a&gt;无障碍化 导航栏与可展开按钮&lt;/h1&gt;&lt;p&gt;测试工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NVDA screen reader （Free screen reader for Windows）&lt;a href=&quot;https://www.nvaccess.org/&quot;&gt;NV Access&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ChromeVox （Free chrome extension）&lt;a href=&quot;https://chrome.google.com/webstore/detail/screen-reader/kgejglhpjiefppelpmljglcjbhoiplfn?hl=en&quot;&gt;Screen Reader - Chrome Web Store (google.com)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码实现：&lt;/p&gt;</summary>
    
    
    
    <category term="无障碍化" scheme="http://example.com/categories/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%8C%96/"/>
    
    
    <category term="无障碍化" scheme="http://example.com/tags/%E6%97%A0%E9%9A%9C%E7%A2%8D%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks 05</title>
    <link href="http://example.com/2022/05/15/React%20Hooks%2005/"/>
    <id>http://example.com/2022/05/15/React%20Hooks%2005/</id>
    <published>2022-05-15T09:22:08.000Z</published>
    <updated>2022-08-01T10:33:44.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Hooks-05"><a href="#React-Hooks-05" class="headerlink" title="React Hooks 05"></a>React Hooks 05</h1><p>useContext()和 useReducer()配合使用可以减少组件层级</p><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext()"></a>useContext()</h2><p>useContext()会创建一个上下文对象，对外暴露消费者和生产者，在上下文之内的所有子组件都可以访问这个上下文环境之内的数据</p><p>简单的说 context 就是对他所包含的组件树提供全局共享数据的技术</p><p>缺点：</p><ol><li>增加调试复杂度，很难跟踪某个 context 的变化是如何产生的</li></ol><span id="more"></span><ol start="2"><li>让组件复用变得困难，因为一个组件使用 context，他必须确保被用到的地方必须有个 context 的 provider 在父组件上</li></ol><p>代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useContext &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个上下文，提供两种不同的页面主题样式</span></span><br><span class="line"><span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: <span class="string">&quot;#000000&quot;</span>,</span><br><span class="line">    background: <span class="string">&quot;#eeeeee&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: <span class="string">&quot;#ffffff&quot;</span>,</span><br><span class="line">    background: <span class="string">&quot;#222222&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(themes.light);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThemedButton做为消费者，通过useContext获取上下文</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemedButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> theme = useContext(ThemeContext);</span><br><span class="line">  <span class="keyword">const</span> [themes, setthemes] = useState(theme.dark);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div</span><br><span class="line">        style=&#123;&#123;</span><br><span class="line">          width: <span class="string">&quot;100px&quot;</span>,</span><br><span class="line">          height: <span class="string">&quot;100px&quot;</span>,</span><br><span class="line">          background: themes.background,</span><br><span class="line">          color: themes.foreground,</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;&lt;/div&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setthemes(theme.light)&#125;&gt;Light&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;<span class="function">() =&gt;</span> setthemes(theme.dark)&#125;&gt;Dark&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个toolbar组件，里面包含了ThemedButton</span></span><br><span class="line"><span class="comment">// ThemeContext.Provider包裹，value就是提供的上下文对象</span></span><br><span class="line"><span class="keyword">const</span> ToolBar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;themes&#125;&gt;</span><br><span class="line">      &lt;ThemedButton /&gt;</span><br><span class="line">    &lt;/ThemeContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ToolBar;</span><br></pre></td></tr></table></figure><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer()"></a>useReducer()</h2><p>工作流程：</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220801182429851.png" alt="image-20220801182429851"></p><p>代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AddAndMinus = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始状态</span></span><br><span class="line">  <span class="keyword">const</span> initState = &#123;</span><br><span class="line">    count: <span class="number">0</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reducer根据action进行逻辑处理</span></span><br><span class="line">  <span class="comment">// preState是老状态</span></span><br><span class="line">  <span class="comment">// action是dispatch过来的</span></span><br><span class="line">  <span class="keyword">const</span> reducer = <span class="function">(<span class="params">preState, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">        <span class="comment">// 不可以直接对preState进行修改</span></span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">count</span>: preState.count + <span class="number">1</span> &#125;;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;minus&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">count</span>: preState.count - <span class="number">1</span> &#125;;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> preState;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅useReducer</span></span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initState);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// dispatch出去</span></span><br><span class="line">          dispatch(&#123;</span><br><span class="line">            type: <span class="string">&quot;add&quot;</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        +</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &#123;state.count&#125;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// dispatch出去</span></span><br><span class="line">          dispatch(&#123;</span><br><span class="line">            type: <span class="string">&quot;minus&quot;</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        -</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> AddAndMinus;</span><br></pre></td></tr></table></figure><p>特点：</p><ol><li>代码变长，但理解起来更简洁明了，拥有更好的可读性</li><li>reducer 可以将逻辑与 ui 分离</li><li>state 都集中到 reducer 中进行处理，更容易复用 state 逻辑变化代码，特别对于 state 变化很复杂的场景</li><li>深层子组件需要修改一些状态，state 变化复杂，一个操作需要修改很多 state，ui 与业务分开维护，优先考虑使用 reducer</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;React-Hooks-05&quot;&gt;&lt;a href=&quot;#React-Hooks-05&quot; class=&quot;headerlink&quot; title=&quot;React Hooks 05&quot;&gt;&lt;/a&gt;React Hooks 05&lt;/h1&gt;&lt;p&gt;useContext()和 useReducer()配合使用可以减少组件层级&lt;/p&gt;
&lt;h2 id=&quot;useContext&quot;&gt;&lt;a href=&quot;#useContext&quot; class=&quot;headerlink&quot; title=&quot;useContext()&quot;&gt;&lt;/a&gt;useContext()&lt;/h2&gt;&lt;p&gt;useContext()会创建一个上下文对象，对外暴露消费者和生产者，在上下文之内的所有子组件都可以访问这个上下文环境之内的数据&lt;/p&gt;
&lt;p&gt;简单的说 context 就是对他所包含的组件树提供全局共享数据的技术&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;增加调试复杂度，很难跟踪某个 context 的变化是如何产生的&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks 04</title>
    <link href="http://example.com/2022/05/12/React%20Hooks%2004/"/>
    <id>http://example.com/2022/05/12/React%20Hooks%2004/</id>
    <published>2022-05-12T04:12:08.000Z</published>
    <updated>2022-08-01T05:34:54.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Hooks-04"><a href="#React-Hooks-04" class="headerlink" title="React Hooks 04"></a>React Hooks 04</h1><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef()"></a>useRef()</h2><p>绑在 html 上保存 dom 节点</p><p>绑在组件上保存组件对象</p><p>代码：</p><span id="more"></span><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;</span><br><span class="line">  useCallback,</span><br><span class="line">  useEffect,</span><br><span class="line">  useMemo,</span><br><span class="line">  useRef,</span><br><span class="line">  useState,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ToDoList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化text与lists</span></span><br><span class="line">  <span class="comment">// const [text, setText] = useState(&quot;&quot;);</span></span><br><span class="line">  <span class="keyword">const</span> [lists, setLists] = useState([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> myText = useRef();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// const handleChange = useCallback((evt) =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   setText(evt.target.value);</span></span><br><span class="line">  <span class="comment">// &#125;, []);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClickAdd = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dom节点</span></span><br><span class="line">    <span class="built_in">console</span>.log(myText);</span><br><span class="line">    <span class="built_in">console</span>.log(myText.current.value);</span><br><span class="line">    setLists([...lists, myText.current.value]);</span><br><span class="line">    <span class="comment">// 不能使用push修改原数组，因为修改数组不会重新渲染页面</span></span><br><span class="line">    <span class="comment">// setLists([...lists, text]);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空input</span></span><br><span class="line">    <span class="comment">// setText(&quot;&quot;);</span></span><br><span class="line">    myText.current.value = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;, [lists]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClickDelete = useCallback(</span><br><span class="line">    (index) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 创建新数组接收lists</span></span><br><span class="line">      <span class="keyword">let</span> newLists = [...lists];</span><br><span class="line">      <span class="comment">// 根据id删除</span></span><br><span class="line">      newLists.splice(index, <span class="number">1</span>);</span><br><span class="line">      setLists(newLists);</span><br><span class="line">    &#125;,</span><br><span class="line">    [lists]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当lists发生改变的时候打印 fuck 996</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;fuck 996&quot;</span>);</span><br><span class="line">  &#125;, [lists]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// useeffect return</span></span><br><span class="line">  <span class="comment">// useEffect(() =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   window.onresize = () =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     console.log(&quot;resize&quot;);</span></span><br><span class="line">  <span class="comment">//   &#125;;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//   let timer = setInterval(() =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     console.log(&quot;fuck&quot;);</span></span><br><span class="line">  <span class="comment">//   &#125;, 1000);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//   // 闭包</span></span><br><span class="line">  <span class="comment">//   return () =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     console.log(&quot;组件销毁时执行&quot;);</span></span><br><span class="line">  <span class="comment">//     window.onresize = null;</span></span><br><span class="line">  <span class="comment">//     timer = clearInterval;</span></span><br><span class="line">  <span class="comment">//   &#125;;</span></span><br><span class="line">  <span class="comment">// &#125;, []);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 给list增加996</span></span><br><span class="line">  <span class="comment">// 没用memo的情况下，当别的状态改变的时候都重新触发该函数</span></span><br><span class="line">  <span class="comment">// let list996 = lists.map((v) =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(&quot;fuck&quot;);</span></span><br><span class="line">  <span class="comment">//   return v + &quot;996&quot;;</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用memo的情况下</span></span><br><span class="line">  <span class="comment">// 只有当依赖中的lists发生改变的时候，才会重新计算</span></span><br><span class="line">  <span class="keyword">const</span> list996 = useMemo(</span><br><span class="line">    () =&gt;</span><br><span class="line">      lists.map(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v + <span class="string">&quot;996&quot;</span>;</span><br><span class="line">      &#125;),</span><br><span class="line">    [lists]</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;myText&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClickAdd&#125;&gt;add to <span class="keyword">do</span> list&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;list996.map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            &lt;div key=&#123;index&#125;&gt;</span><br><span class="line">              &lt;div&gt;&#123;value&#125;&lt;/div&gt;</span><br><span class="line">              &lt;button</span><br><span class="line">                onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                  handleClickDelete(index);</span><br><span class="line">                &#125;&#125;</span><br><span class="line">              &gt;</span><br><span class="line">                <span class="keyword">delete</span></span><br><span class="line">              &lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          );</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ToDoList;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;React-Hooks-04&quot;&gt;&lt;a href=&quot;#React-Hooks-04&quot; class=&quot;headerlink&quot; title=&quot;React Hooks 04&quot;&gt;&lt;/a&gt;React Hooks 04&lt;/h1&gt;&lt;h2 id=&quot;useRef&quot;&gt;&lt;a href=&quot;#useRef&quot; class=&quot;headerlink&quot; title=&quot;useRef()&quot;&gt;&lt;/a&gt;useRef()&lt;/h2&gt;&lt;p&gt;绑在 html 上保存 dom 节点&lt;/p&gt;
&lt;p&gt;绑在组件上保存组件对象&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks 03</title>
    <link href="http://example.com/2022/05/11/React%20Hooks%2003/"/>
    <id>http://example.com/2022/05/11/React%20Hooks%2003/</id>
    <published>2022-05-11T12:11:31.000Z</published>
    <updated>2022-07-31T17:49:37.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Hooks-03"><a href="#React-Hooks-03" class="headerlink" title="React Hooks 03"></a>React Hooks 03</h1><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo()"></a>useMemo()</h2><p>记忆组件</p><p>与 useCallback()的区别</p><ol><li>useCallback()不会执行第一个参数函数，而是将它返回</li><li>useMemo()则是执行第一个函数参数，将函数的执行结果返回</li></ol><p>代码</p><span id="more"></span><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给list增加996</span></span><br><span class="line"><span class="comment">// 没用memo的情况下，当别的状态改变的时候都重新触发该函数</span></span><br><span class="line"><span class="comment">// let list996 = lists.map((v) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&quot;fuck&quot;);</span></span><br><span class="line"><span class="comment">//   return v + &quot;996&quot;;</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用memo的情况下</span></span><br><span class="line"><span class="comment">// 只有当依赖中的lists发生改变的时候，才会重新计算</span></span><br><span class="line"><span class="keyword">const</span> list996 = useMemo(</span><br><span class="line">  () =&gt;</span><br><span class="line">    lists.map(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> v + <span class="string">&quot;996&quot;</span>;</span><br><span class="line">    &#125;),</span><br><span class="line">  [lists]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;React-Hooks-03&quot;&gt;&lt;a href=&quot;#React-Hooks-03&quot; class=&quot;headerlink&quot; title=&quot;React Hooks 03&quot;&gt;&lt;/a&gt;React Hooks 03&lt;/h1&gt;&lt;h2 id=&quot;useMemo&quot;&gt;&lt;a href=&quot;#useMemo&quot; class=&quot;headerlink&quot; title=&quot;useMemo()&quot;&gt;&lt;/a&gt;useMemo()&lt;/h2&gt;&lt;p&gt;记忆组件&lt;/p&gt;
&lt;p&gt;与 useCallback()的区别&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;useCallback()不会执行第一个参数函数，而是将它返回&lt;/li&gt;
&lt;li&gt;useMemo()则是执行第一个函数参数，将函数的执行结果返回&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks 02</title>
    <link href="http://example.com/2022/05/10/React%20Hooks%2002/"/>
    <id>http://example.com/2022/05/10/React%20Hooks%2002/</id>
    <published>2022-05-09T16:31:51.000Z</published>
    <updated>2022-07-31T17:32:29.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Hooks-02"><a href="#React-Hooks-02" class="headerlink" title="React Hooks 02"></a>React Hooks 02</h1><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback()"></a>useCallback()</h2><ol><li>记忆函数，防止因为组件渲染导致的函数重新创建，起到缓存作用</li><li>当依赖中的参数发生改变则会重新生命函数</li><li>当与之无关的状态发生改变的时候导致页面渲染，则不会重新声明函数</li></ol><p>代码：</p><span id="more"></span><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleChange = useCallback(<span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">  setText(evt.target.value);</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleClickAdd = useCallback(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 不能使用push修改原数组，因为修改数组不会重新渲染页面</span></span><br><span class="line">  setLists([...lists, text]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清空input</span></span><br><span class="line">  setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;, [lists, text]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleClickDelete = useCallback(</span><br><span class="line">  (index) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 创建新数组接收lists</span></span><br><span class="line">    <span class="keyword">let</span> newLists = [...lists];</span><br><span class="line">    <span class="comment">// 根据id删除</span></span><br><span class="line">    newLists.splice(index, <span class="number">1</span>);</span><br><span class="line">    setLists(newLists);</span><br><span class="line">  &#125;,</span><br><span class="line">  [lists]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;React-Hooks-02&quot;&gt;&lt;a href=&quot;#React-Hooks-02&quot; class=&quot;headerlink&quot; title=&quot;React Hooks 02&quot;&gt;&lt;/a&gt;React Hooks 02&lt;/h1&gt;&lt;h2 id=&quot;useCallback&quot;&gt;&lt;a href=&quot;#useCallback&quot; class=&quot;headerlink&quot; title=&quot;useCallback()&quot;&gt;&lt;/a&gt;useCallback()&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;记忆函数，防止因为组件渲染导致的函数重新创建，起到缓存作用&lt;/li&gt;
&lt;li&gt;当依赖中的参数发生改变则会重新生命函数&lt;/li&gt;
&lt;li&gt;当与之无关的状态发生改变的时候导致页面渲染，则不会重新声明函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码：&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks 01</title>
    <link href="http://example.com/2022/05/09/React%20Hooks%2001/"/>
    <id>http://example.com/2022/05/09/React%20Hooks%2001/</id>
    <published>2022-05-09T14:41:40.000Z</published>
    <updated>2022-07-31T16:32:48.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Hooks-01"><a href="#React-Hooks-01" class="headerlink" title="React Hooks 01"></a>React Hooks 01</h1><h2 id="useState"><a href="#useState" class="headerlink" title="useState()"></a>useState()</h2><p>用一个简单的 todolist demo 来演示 useState()的作用：</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220731233818028.png" alt="image-20220731233818028"></p><p>代码：</p><span id="more"></span><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ToDoList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化text与lists</span></span><br><span class="line">  <span class="keyword">const</span> [text, setText] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [lists, setLists] = useState([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleChange = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">    setText(evt.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClickAdd = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 不能使用push修改原数组，因为修改数组不会重新渲染页面</span></span><br><span class="line">    setLists([...lists, text]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空input</span></span><br><span class="line">    setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClickDelete = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建新数组接收lists</span></span><br><span class="line">    <span class="keyword">let</span> newLists = [...lists];</span><br><span class="line">    <span class="comment">// 根据id删除</span></span><br><span class="line">    newLists.splice(index, <span class="number">1</span>);</span><br><span class="line">    setLists(newLists);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input onChange=&#123;handleChange&#125; value=&#123;text&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClickAdd&#125;&gt;add to <span class="keyword">do</span> list&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;lists.map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            &lt;div key=&#123;index&#125;&gt;</span><br><span class="line">              &lt;div&gt;&#123;value&#125;&lt;/div&gt;</span><br><span class="line">              &lt;button</span><br><span class="line">                onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                  handleClickDelete(index);</span><br><span class="line">                &#125;&#125;</span><br><span class="line">              &gt;</span><br><span class="line">                <span class="keyword">delete</span></span><br><span class="line">              &lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          );</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ToDoList;</span><br></pre></td></tr></table></figure><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect()"></a>useEffect()</h2><p>可以代替类组件中的生命周期</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220731234839234.png" alt="image-20220731234839234"></p><ol><li>当依赖数组为空数组的时候表示不依赖，useeffect 在渲染的时候只会执行一次</li><li>如果依赖数组中有依赖，当依赖值发生改变的时候，会重新执行 useEffect()</li></ol><p>代码演示：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ToDoList = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化text与lists</span></span><br><span class="line">  <span class="keyword">const</span> [text, setText] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> [lists, setLists] = useState([]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleChange = <span class="function">(<span class="params">evt</span>) =&gt;</span> &#123;</span><br><span class="line">    setText(evt.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClickAdd = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 不能使用push修改原数组，因为修改数组不会重新渲染页面</span></span><br><span class="line">    setLists([...lists, text]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空input</span></span><br><span class="line">    setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClickDelete = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建新数组接收lists</span></span><br><span class="line">    <span class="keyword">let</span> newLists = [...lists];</span><br><span class="line">    <span class="comment">// 根据id删除</span></span><br><span class="line">    newLists.splice(index, <span class="number">1</span>);</span><br><span class="line">    setLists(newLists);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 当lists发生改变的时候打印 fuck 996</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;fuck 996&quot;</span>);</span><br><span class="line">  &#125;, [lists]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input onChange=&#123;handleChange&#125; value=&#123;text&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClickAdd&#125;&gt;add to <span class="keyword">do</span> list&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;lists.map(<span class="function">(<span class="params">value, index</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> (</span><br><span class="line">            &lt;div key=&#123;index&#125;&gt;</span><br><span class="line">              &lt;div&gt;&#123;value&#125;&lt;/div&gt;</span><br><span class="line">              &lt;button</span><br><span class="line">                onClick=&#123;<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                  handleClickDelete(index);</span><br><span class="line">                &#125;&#125;</span><br><span class="line">              &gt;</span><br><span class="line">                <span class="keyword">delete</span></span><br><span class="line">              &lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">          );</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ToDoList;</span><br></pre></td></tr></table></figure><ol start="3"><li>useeffec()中的 return 回调函数，在没有依赖的时候，当组件销毁的时候执行，如果有依赖则每次依赖发生变化和组件销毁的时候执行</li></ol><p>代码演示</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useeffect return</span></span><br><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.onresize = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;resize&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;fuck&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;组件销毁时执行&quot;</span>);</span><br><span class="line">    <span class="built_in">window</span>.onresize = <span class="literal">null</span>;</span><br><span class="line">    timer = <span class="built_in">clearInterval</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect()"></a>useLayoutEffect()</h2><p>useEffect()与 useLayoutEffect()的区别</p><ol><li>useLayoutEffect()在 react 更新完 dom 树后会立即<strong>同步调用</strong>里面的代码，会阻塞页面渲染（渲染树）<ul><li>useEffect()在页面渲染完后才调用，因此一般情况 useEffect()效果更好</li></ul></li><li>如果做纯 dom 操作，推荐使用 useLayoutEffect()<ul><li><strong>避免抖动</strong>，在 useLayoutEffect()中做的 dom 操作会和 react 做出的更改一起被一次性渲染到页面，只有一次回流重绘的代价</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;React-Hooks-01&quot;&gt;&lt;a href=&quot;#React-Hooks-01&quot; class=&quot;headerlink&quot; title=&quot;React Hooks 01&quot;&gt;&lt;/a&gt;React Hooks 01&lt;/h1&gt;&lt;h2 id=&quot;useState&quot;&gt;&lt;a href=&quot;#useState&quot; class=&quot;headerlink&quot; title=&quot;useState()&quot;&gt;&lt;/a&gt;useState()&lt;/h2&gt;&lt;p&gt;用一个简单的 todolist demo 来演示 useState()的作用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220731233818028.png&quot; alt=&quot;image-20220731233818028&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="http://example.com/categories/React/"/>
    
    
    <category term="React" scheme="http://example.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 模拟实现call apply bind方法</title>
    <link href="http://example.com/2022/04/08/JavaScript%20%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%20apply%20bind%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/04/08/JavaScript%20%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%20apply%20bind%E6%96%B9%E6%B3%95/</id>
    <published>2022-04-08T10:21:56.000Z</published>
    <updated>2022-08-01T05:39:41.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-模拟实现-call-apply-bind-方法"><a href="#JavaScript-模拟实现-call-apply-bind-方法" class="headerlink" title="JavaScript 模拟实现 call apply bind 方法"></a>JavaScript 模拟实现 call apply bind 方法</h1><p>首先来说下这三个的区别：</p><ul><li><code>call</code> <code>apply</code>都是为了解决 this 的指向，默认第一参数是 this 的指向，剩下的参数是函数形参，<code>call</code>接收的形参是一个列表用逗号隔开，<code>apply</code>接收的是一个参数数组。</li><li><code>call</code> <code>apply</code>改变函数的 this 指向以后立马执行该函数，而<code>bind</code>是返回一个绑定上下文的新函数，后续再执行。</li><li>bind 函数返回的新函数不可以再通过 apply call 改变它的 this 指向。</li></ul><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">getValue.call(a, <span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;24&quot;</span>); <span class="comment">// fuck 24 1; 立即执行</span></span><br><span class="line">getValue.apply(a, [<span class="string">&quot;shit&quot;</span>, <span class="string">&quot;24&quot;</span>]); <span class="comment">// shit 24 1；立即执行</span></span><br><span class="line">getValue.bind(a)(<span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;24&quot;</span>); <span class="comment">// fuck 24 1；(&#x27;fuck&#x27;, &#x27;24&#x27;)这部分才是执行函数</span></span><br><span class="line">getValue.bind(a)([<span class="string">&quot;shit&quot;</span>, <span class="string">&quot;24&quot;</span>]); <span class="comment">// [&#x27;shit&#x27;, &#x27;24&#x27;] undefined 1；([&#x27;shit&#x27;, &#x27;24&#x27;])才是执行函数</span></span><br></pre></td></tr></table></figure><h2 id="模拟实现-call"><a href="#模拟实现-call" class="headerlink" title="模拟实现 call"></a>模拟实现 call</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  <span class="comment">// 给 context 添加一个属性</span></span><br><span class="line">  <span class="comment">// getValue.call(a, &#x27;fuck&#x27;, &#x27;24&#x27;) =&gt; a.fn = getValue</span></span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 将 context 后面的参数取出来</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">// getValue.call(a, &#x27;fuck&#x27;, &#x27;24&#x27;) =&gt; a.fn(&#x27;fuck&#x27;, &#x27;24&#x27;)</span></span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">  <span class="comment">// 删除 fn</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">getValue.myCall(a, <span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;24&quot;</span>); <span class="comment">//fuck 24 1</span></span><br></pre></td></tr></table></figure><h2 id="模拟实现-apply"><a href="#模拟实现-apply" class="headerlink" title="模拟实现 apply"></a>模拟实现 apply</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> result;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">getValue.myApply(a, [<span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;24&quot;</span>]); <span class="comment">//fuck 24 1</span></span><br></pre></td></tr></table></figure><h2 id="模拟实现-bind"><a href="#模拟实现-bind" class="headerlink" title="模拟实现 bind"></a>模拟实现 bind</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, args.concat(...arguments));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">getValue.myBind(a, <span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;24&quot;</span>)(); <span class="comment">//fuck 24 1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JavaScript-模拟实现-call-apply-bind-方法&quot;&gt;&lt;a href=&quot;#JavaScript-模拟实现-call-apply-bind-方法&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 模拟实现 call apply bind 方法&quot;&gt;&lt;/a&gt;JavaScript 模拟实现 call apply bind 方法&lt;/h1&gt;&lt;p&gt;首先来说下这三个的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;call&lt;/code&gt; &lt;code&gt;apply&lt;/code&gt;都是为了解决 this 的指向，默认第一参数是 this 的指向，剩下的参数是函数形参，&lt;code&gt;call&lt;/code&gt;接收的形参是一个列表用逗号隔开，&lt;code&gt;apply&lt;/code&gt;接收的是一个参数数组。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;call&lt;/code&gt; &lt;code&gt;apply&lt;/code&gt;改变函数的 this 指向以后立马执行该函数，而&lt;code&gt;bind&lt;/code&gt;是返回一个绑定上下文的新函数，后续再执行。&lt;/li&gt;
&lt;li&gt;bind 函数返回的新函数不可以再通过 apply call 改变它的 this 指向。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的构造02</title>
    <link href="http://example.com/2022/03/13/Leetcode%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A002/"/>
    <id>http://example.com/2022/03/13/Leetcode%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A002/</id>
    <published>2022-03-13T09:11:39.000Z</published>
    <updated>2022-07-29T08:50:33.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-二叉树的构造-02"><a href="#Leetcode-二叉树的构造-02" class="headerlink" title="Leetcode 二叉树的构造 02"></a>Leetcode 二叉树的构造 02</h1><h2 id="前序-后序-构造二叉树"><a href="#前序-后序-构造二叉树" class="headerlink" title="前序+后序 构造二叉树"></a>前序+后序 构造二叉树</h2><p>只能确定根节点，但是不能确定左右子树，因此答案不唯一</p><p>题号：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><p>解题流程：</p><p>1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。</p><p>2、然后把前序遍历结果的第二个元素作为左子树的根节点的值。</p><span id="more"></span><p>3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可。</p><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">preorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">postorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> constructFromPrePost = <span class="function"><span class="keyword">function</span> (<span class="params">preorder, postorder</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 根左右</span></span><br><span class="line">  <span class="comment">// 左右根</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> build = <span class="function">(<span class="params">preorder, preStart, preEnd, postorder, postStart, postEnd</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (preStart &gt; preEnd) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (preStart === preEnd) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[preStart]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历数组的第一个元素为根节点</span></span><br><span class="line">    <span class="keyword">let</span> rootVal = preorder[preStart];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到左子树的根节点</span></span><br><span class="line">    <span class="comment">// 左子树的根节点为前序遍历数组中的第二个元素（左子树可能为null，因此该元素可能是右子树的根节点，因此本题答案不唯一）</span></span><br><span class="line">    <span class="keyword">let</span> leftVal = preorder[preStart + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到左子树根节点在后续遍历数组中的位置</span></span><br><span class="line">    <span class="keyword">let</span> leftIndex = postorder.indexOf(leftVal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左子树数组长度</span></span><br><span class="line">    <span class="keyword">let</span> leftSize = leftIndex - postStart + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line"></span><br><span class="line">    root.left = build(</span><br><span class="line">      preorder,</span><br><span class="line">      preStart + <span class="number">1</span>,</span><br><span class="line">      preStart + leftSize,</span><br><span class="line">      postorder,</span><br><span class="line">      postStart,</span><br><span class="line">      leftIndex</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    root.right = build(</span><br><span class="line">      preorder,</span><br><span class="line">      preStart + leftSize + <span class="number">1</span>,</span><br><span class="line">      preEnd,</span><br><span class="line">      postorder,</span><br><span class="line">      leftIndex + <span class="number">1</span>,</span><br><span class="line">      postEnd - <span class="number">1</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> build(</span><br><span class="line">    preorder,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    preorder.length - <span class="number">1</span>,</span><br><span class="line">    postorder,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    postorder.length - <span class="number">1</span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Leetcode-二叉树的构造-02&quot;&gt;&lt;a href=&quot;#Leetcode-二叉树的构造-02&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 二叉树的构造 02&quot;&gt;&lt;/a&gt;Leetcode 二叉树的构造 02&lt;/h1&gt;&lt;h2 id=&quot;前序-后序-构造二叉树&quot;&gt;&lt;a href=&quot;#前序-后序-构造二叉树&quot; class=&quot;headerlink&quot; title=&quot;前序+后序 构造二叉树&quot;&gt;&lt;/a&gt;前序+后序 构造二叉树&lt;/h2&gt;&lt;p&gt;只能确定根节点，但是不能确定左右子树，因此答案不唯一&lt;/p&gt;
&lt;p&gt;题号：&lt;a href=&quot;https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/&quot;&gt;105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解题流程：&lt;/p&gt;
&lt;p&gt;1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值。&lt;/p&gt;
&lt;p&gt;2、然后把前序遍历结果的第二个元素作为左子树的根节点的值。&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://example.com/categories/Leetcode/"/>
    
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的构造01</title>
    <link href="http://example.com/2022/03/13/Leetcode%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A001/"/>
    <id>http://example.com/2022/03/13/Leetcode%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A001/</id>
    <published>2022-03-13T08:21:20.000Z</published>
    <updated>2022-07-29T08:42:03.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-二叉树的构造-01"><a href="#Leetcode-二叉树的构造-01" class="headerlink" title="Leetcode 二叉树的构造 01"></a>Leetcode 二叉树的构造 01</h1><h2 id="前序-中序-构造二叉树"><a href="#前序-中序-构造二叉树" class="headerlink" title="前序+中序 构造二叉树"></a>前序+中序 构造二叉树</h2><p>题号：<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><p>代码：</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">preorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">inorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span> (<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> build = <span class="function">(<span class="params">preorder, preStart, preEnd, inorder, inStart, inEnd</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (preStart &gt; preEnd) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历数组的第一个元素是 树的根节点</span></span><br><span class="line">    <span class="keyword">let</span> rootVal = preorder[preStart];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到根节点在中序遍历数组中的索引</span></span><br><span class="line">    <span class="keyword">let</span> rootIndex = inorder.indexOf(rootVal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据根节点的索引在中序遍历数组中定位左子树数组的长度</span></span><br><span class="line">    <span class="keyword">let</span> leftSize = rootIndex - inStart;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归构造左右子树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据左子树数组的长度定位到</span></span><br><span class="line">    <span class="comment">// 左子树在前序遍历数组中的位置</span></span><br><span class="line">    <span class="comment">// 根节点的后一个节点 到 根节点位置+长度</span></span><br><span class="line">    <span class="comment">// 左子树在中序遍历数组中的位置</span></span><br><span class="line">    <span class="comment">// 中序遍历开始的位置，到根节点前一个元素</span></span><br><span class="line">    root.left = build(</span><br><span class="line">      preorder,</span><br><span class="line">      preStart + <span class="number">1</span>,</span><br><span class="line">      preStart + leftSize,</span><br><span class="line">      inorder,</span><br><span class="line">      inStart,</span><br><span class="line">      rootIndex - <span class="number">1</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 右子树在前序遍历数组中的位置</span></span><br><span class="line">    <span class="comment">// 根节点位置+长度+1</span></span><br><span class="line">    <span class="comment">// 右子树在中序遍历数组中的位置</span></span><br><span class="line">    <span class="comment">// 根节点元素位置+1，到数组结尾</span></span><br><span class="line">    root.right = build(</span><br><span class="line">      preorder,</span><br><span class="line">      preStart + leftSize + <span class="number">1</span>,</span><br><span class="line">      preEnd,</span><br><span class="line">      inorder,</span><br><span class="line">      rootIndex + <span class="number">1</span>,</span><br><span class="line">      inEnd</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> build(</span><br><span class="line">    preorder,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    preorder.length - <span class="number">1</span>,</span><br><span class="line">    inorder,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    inorder.length - <span class="number">1</span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="后序-中序-构造二叉树"><a href="#后序-中序-构造二叉树" class="headerlink" title="后序+中序 构造二叉树"></a>后序+中序 构造二叉树</h2><p>题号：<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）</a></p><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">inorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">postorder</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;TreeNode&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span> (<span class="params">inorder, postorder</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> build = <span class="function">(<span class="params">inorder, inStart, inEnd, postorder, postStart, postEnd</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (inStart &gt; inEnd) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="comment">// [左，根，右]</span></span><br><span class="line">    <span class="comment">// 后续遍历</span></span><br><span class="line">    <span class="comment">// [左，右，根]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后续遍历数组的最后一位为根节点</span></span><br><span class="line">    <span class="keyword">let</span> rootVal = postorder[postEnd];</span><br><span class="line">    <span class="comment">// 找到根节点在中序遍历数组中的位置</span></span><br><span class="line">    <span class="keyword">let</span> rootIndex = inorder.indexOf(rootVal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造二叉树</span></span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得左子树数组的长度</span></span><br><span class="line">    <span class="keyword">let</span> leftSize = rootIndex - inStart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造二叉树的左右子树</span></span><br><span class="line">    root.left = build(</span><br><span class="line">      inorder,</span><br><span class="line">      inStart,</span><br><span class="line">      rootIndex - <span class="number">1</span>,</span><br><span class="line">      postorder,</span><br><span class="line">      postStart,</span><br><span class="line">      postStart + leftSize - <span class="number">1</span></span><br><span class="line">    );</span><br><span class="line">    root.right = build(</span><br><span class="line">      inorder,</span><br><span class="line">      rootIndex + <span class="number">1</span>,</span><br><span class="line">      inEnd,</span><br><span class="line">      postorder,</span><br><span class="line">      postStart + leftSize,</span><br><span class="line">      postEnd - <span class="number">1</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> build(</span><br><span class="line">    inorder,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    inorder.length - <span class="number">1</span>,</span><br><span class="line">    postorder,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    postorder.length - <span class="number">1</span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Leetcode-二叉树的构造-01&quot;&gt;&lt;a href=&quot;#Leetcode-二叉树的构造-01&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 二叉树的构造 01&quot;&gt;&lt;/a&gt;Leetcode 二叉树的构造 01&lt;/h1&gt;&lt;h2 id=&quot;前序-中序-构造二叉树&quot;&gt;&lt;a href=&quot;#前序-中序-构造二叉树&quot; class=&quot;headerlink&quot; title=&quot;前序+中序 构造二叉树&quot;&gt;&lt;/a&gt;前序+中序 构造二叉树&lt;/h2&gt;&lt;p&gt;题号：&lt;a href=&quot;https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/&quot;&gt;105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://example.com/categories/Leetcode/"/>
    
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的层序遍历</title>
    <link href="http://example.com/2022/03/10/Leetcode%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://example.com/2022/03/10/Leetcode%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-03-10T03:01:20.000Z</published>
    <updated>2022-07-29T08:26:40.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-二叉树的层序遍历"><a href="#Leetcode-二叉树的层序遍历" class="headerlink" title="Leetcode 二叉树的层序遍历"></a>Leetcode 二叉树的层序遍历</h1><p>前文分别用递归和迭代遍历二叉树，本文讲一下层序遍历二叉树（BFS）</p><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>题号：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（LeetCode）</a></p><p>代码：</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> queue = [];</span><br><span class="line">  queue.push(root);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// while循环控制从上到下遍历</span></span><br><span class="line">  <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> size = queue.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> level = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for循环控制从左到右遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> cur = queue.shift();</span><br><span class="line">      level.push(cur.val);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cur.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.push(cur.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cur.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">        queue.push(cur.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.push([...level]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Leetcode-二叉树的层序遍历&quot;&gt;&lt;a href=&quot;#Leetcode-二叉树的层序遍历&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 二叉树的层序遍历&quot;&gt;&lt;/a&gt;Leetcode 二叉树的层序遍历&lt;/h1&gt;&lt;p&gt;前文分别用递归和迭代遍历二叉树，本文讲一下层序遍历二叉树（BFS）&lt;/p&gt;
&lt;h2 id=&quot;层序遍历&quot;&gt;&lt;a href=&quot;#层序遍历&quot; class=&quot;headerlink&quot; title=&quot;层序遍历&quot;&gt;&lt;/a&gt;层序遍历&lt;/h2&gt;&lt;p&gt;题号：&lt;a href=&quot;https://leetcode.cn/problems/binary-tree-level-order-traversal/&quot;&gt;102. 二叉树的层序遍历 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://example.com/categories/Leetcode/"/>
    
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前中后序遍历（迭代）</title>
    <link href="http://example.com/2022/03/04/Leetcode%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%EF%BC%89/"/>
    <id>http://example.com/2022/03/04/Leetcode%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%EF%BC%89/</id>
    <published>2022-03-04T02:55:05.000Z</published>
    <updated>2022-07-29T07:57:00.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-二叉树的前中后序遍历（迭代）"><a href="#Leetcode-二叉树的前中后序遍历（迭代）" class="headerlink" title="Leetcode 二叉树的前中后序遍历（迭代）"></a>Leetcode 二叉树的前中后序遍历（迭代）</h1><p>前文讲过二叉树的递归遍历版本，今天讲一下二叉树的迭代遍历</p><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>题号：<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></p><p>顺序：根节点 左节点 右节点</p><p>代码：</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 前序遍历</span></span><br><span class="line">  <span class="comment">// 根节点 左节点 右节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代</span></span><br><span class="line">  <span class="comment">// 需要借助栈来实现</span></span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">while</span> (root !== <span class="literal">null</span> || stack.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 先把根节点记录下来</span></span><br><span class="line">      result.push(root.val);</span><br><span class="line">      stack.push(root);</span><br><span class="line">      root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    root = stack.pop();</span><br><span class="line">    root = root.right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>题号：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></p><p>顺序：左节点 根节点 右节点</p><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 中序遍历</span></span><br><span class="line">  <span class="comment">// 左子树 根节点 右子树</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代</span></span><br><span class="line">  <span class="comment">// 借助栈</span></span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当二叉树遍历完毕 或者 栈中没有元素 停止遍历</span></span><br><span class="line">  <span class="keyword">while</span> (root !== <span class="literal">null</span> || stack.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 将根节点到所有的左节点存入栈中</span></span><br><span class="line">    <span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      stack.push(root);</span><br><span class="line">      root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始出栈</span></span><br><span class="line">    root = stack.pop();</span><br><span class="line">    <span class="comment">// 出栈元素存入result</span></span><br><span class="line">    result.push(root.val);</span><br><span class="line">    <span class="comment">// 将root改为原root的右节点</span></span><br><span class="line">    root = root.right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><p>题号：<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历 - 力扣（LeetCode）</a></p><p>顺序：左节点 右节点 根节点</p><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归</span></span><br><span class="line">  <span class="comment">// 后续遍历</span></span><br><span class="line">  <span class="comment">// 左节点 右节点 根节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代</span></span><br><span class="line">  <span class="comment">// 借助栈 以及 中间变量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> preAccess = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (root !== <span class="literal">null</span> || stack.length !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (root !== <span class="literal">null</span>) &#123;</span><br><span class="line">      stack.push(root);</span><br><span class="line">      root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (root.right === <span class="literal">null</span> || root.right === preAccess) &#123;</span><br><span class="line">      result.push(root.val);</span><br><span class="line">      preAccess = root;</span><br><span class="line">      root = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      stack.push(root);</span><br><span class="line">      root = root.right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Leetcode-二叉树的前中后序遍历（迭代）&quot;&gt;&lt;a href=&quot;#Leetcode-二叉树的前中后序遍历（迭代）&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 二叉树的前中后序遍历（迭代）&quot;&gt;&lt;/a&gt;Leetcode 二叉树的前中后序遍历（迭代）&lt;/h1&gt;&lt;p&gt;前文讲过二叉树的递归遍历版本，今天讲一下二叉树的迭代遍历&lt;/p&gt;
&lt;h2 id=&quot;前序遍历&quot;&gt;&lt;a href=&quot;#前序遍历&quot; class=&quot;headerlink&quot; title=&quot;前序遍历&quot;&gt;&lt;/a&gt;前序遍历&lt;/h2&gt;&lt;p&gt;题号：&lt;a href=&quot;https://leetcode.cn/problems/binary-tree-preorder-traversal/&quot;&gt;144. 二叉树的前序遍历 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;顺序：根节点 左节点 右节点&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://example.com/categories/Leetcode/"/>
    
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前中后序遍历（递归）</title>
    <link href="http://example.com/2022/03/04/Leetcode%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89/"/>
    <id>http://example.com/2022/03/04/Leetcode%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89/</id>
    <published>2022-03-04T02:14:38.000Z</published>
    <updated>2022-07-29T07:01:44.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-二叉树的前中后序遍历（递归）"><a href="#Leetcode-二叉树的前中后序遍历（递归）" class="headerlink" title="Leetcode 二叉树的前中后序遍历（递归）"></a>Leetcode 二叉树的前中后序遍历（递归）</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>题号：<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历 - 力扣（LeetCode）</a></p><p>顺序：根节点 左节点 右节点</p><p>代码：</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 前序遍历</span></span><br><span class="line">  <span class="comment">// 根节点 左节点 右节点</span></span><br><span class="line">  <span class="comment">// 递归</span></span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">const</span> accessTree = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(root.val);</span><br><span class="line">    accessTree(root.left);</span><br><span class="line">    accessTree(root.right);</span><br><span class="line">  &#125;;</span><br><span class="line">  accessTree(root);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>题号：<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历 - 力扣（LeetCode）</a></p><p>顺序：左节点 根节点 右节点</p><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 中序遍历</span></span><br><span class="line">  <span class="comment">// 左子树 根节点 右子树</span></span><br><span class="line">  <span class="comment">// 递归</span></span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">const</span> accessTree = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    accessTree(root.left);</span><br><span class="line">    result.push(root.val);</span><br><span class="line">    accessTree(root.right);</span><br><span class="line">  &#125;;</span><br><span class="line">  accessTree(root);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h2><p>题号：<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历 - 力扣（LeetCode）</a></p><p>顺序：左节点 右节点 根节点</p><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val, left, right) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *     this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;TreeNode&#125;</span> <span class="variable">root</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归</span></span><br><span class="line">  <span class="comment">// 后续遍历</span></span><br><span class="line">  <span class="comment">// 左节点 右节点 根节点</span></span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">const</span> accessTree = <span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    accessTree(root.left);</span><br><span class="line">    accessTree(root.right);</span><br><span class="line">    result.push(root.val);</span><br><span class="line">  &#125;;</span><br><span class="line">  accessTree(root);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Leetcode-二叉树的前中后序遍历（递归）&quot;&gt;&lt;a href=&quot;#Leetcode-二叉树的前中后序遍历（递归）&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 二叉树的前中后序遍历（递归）&quot;&gt;&lt;/a&gt;Leetcode 二叉树的前中后序遍历（递归）&lt;/h1&gt;&lt;h2 id=&quot;前序遍历&quot;&gt;&lt;a href=&quot;#前序遍历&quot; class=&quot;headerlink&quot; title=&quot;前序遍历&quot;&gt;&lt;/a&gt;前序遍历&lt;/h2&gt;&lt;p&gt;题号：&lt;a href=&quot;https://leetcode.cn/problems/binary-tree-preorder-traversal/&quot;&gt;144. 二叉树的前序遍历 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;顺序：根节点 左节点 右节点&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;</summary>
    
    
    
    <category term="Leetcode" scheme="http://example.com/categories/Leetcode/"/>
    
    
    <category term="Leetcode" scheme="http://example.com/tags/Leetcode/"/>
    
  </entry>
  
</feed>
