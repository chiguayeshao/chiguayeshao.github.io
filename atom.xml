<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SunleDog</title>
  
  <subtitle>SunleDog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-28T03:24:34.832Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>XIotian Ye</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript 详解Event Loop运行机制</title>
    <link href="http://example.com/2021/10/08/JavaScript%20%E8%AF%A6%E8%A7%A3Event-Loop%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/10/08/JavaScript%20%E8%AF%A6%E8%A7%A3Event-Loop%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2021-10-08T09:35:04.000Z</published>
    <updated>2022-07-28T03:24:34.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-详解-Event-Loop-运行机制"><a href="#JavaScript-详解-Event-Loop-运行机制" class="headerlink" title="JavaScript 详解 Event Loop 运行机制"></a>JavaScript 详解 Event Loop 运行机制</h1><p>在这篇文章中会介绍以下内容：</p><ul><li><p>engine runtime 和 call stack 简介（以 V8 引擎为例）</p></li><li><p>Event Loop 运行机制的详解</p></li><li><p>microtasks 和 macrotask 的执行顺序</p></li></ul><h2 id="engine-runtime-和-call-stack-简介"><a href="#engine-runtime-和-call-stack-简介" class="headerlink" title="engine runtime 和 call stack 简介"></a>engine runtime 和 call stack 简介</h2><p>在 chrome 浏览器和 nodejs 里都是用 V8 引擎解析和运行 JS 代码，我们先来看下 V8 引擎的简化图：</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop01-20220728111457618.png" alt="js-eventloop01"></p><p>上图中 Heap 是用来做内存分配，<code>Call Stack</code>是用来执行 JS 代码，由于 JS 是单线程所以只有一个<code>Call Stack</code>。实际我们写网页开发的时候，除了一些 JS 代码，我们还会大量用到：DOM 事件、AJAX(XMLHttpRequest)、setTimeout 等等一些异步事件。从上图可以看出，这些异步事件都没有在 V8 引擎里，事实上这些异步事件不属于 V8 引擎，而是属于浏览器，并且 DOM 事件、AJAX(XMLHttpRequest)、setTimeout 都分别有单独的线程来处理。由于<code>Call Stack</code>执行（JS 运行线程）和页面渲染线程是互斥的，如果所有的事情都由 V8 引擎处理，这样肯定会导致页面卡顿。</p><p>浏览器多线程和 callback 机制完美避免了页面卡顿的问题。DOM 事件、AJAX(XMLHttpRequest)、setTimeout 这些异步事件在各自单独的线程处理完以后，每个异步事件都有 callback 回调函数，V8 引擎再把这些回调函数放在<code>Call Stack</code>执行。上述整个运行机制可以称为是 runtime，可以简化如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop02.png" alt="js-eventloop02"></p><p>如上图所示，web 异步事件结束以后，会有 callback，然后 runtime 把这些 callback 事件放到<code>Callback Queue</code>里，一旦<code>Call Stack</code>所有的方法都执行完以后，<code>Event Loop</code>会依次把 <code>Callback Queue</code>里的回调函数放到<code>Call Stack</code>里执行。</p><h2 id="Event-Loop-运行机制的详解"><a href="#Event-Loop-运行机制的详解" class="headerlink" title="Event Loop 运行机制的详解"></a>Event Loop 运行机制的详解</h2><p>Event Loop 实际上就是一个 job，用来检测 Call Stack 和 Callback Queue，一旦 Call Stack 里代码执行完以后，就会把 Callback Queue 里第一个 callback 函数放到 Call Stack 里执行。我们来看个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行运行结果如下:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">script</span> start</span><br><span class="line"><span class="keyword">script</span> <span class="keyword">end</span></span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure><p>我们具体一步一步看下整个流程：</p><p>1，代码没有运行之前，<code>Call Stack</code> <code>Callback Queue</code>都是空的</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop03.png" alt="js-eventloop03"></p><p>2，把<code>console.log(&#39;script start&#39;)</code>加到 Call Stack</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop04.png" alt="js-eventloop04"></p><p>3，执行<code>console.log(&#39;script start&#39;)</code>，在 console 里打印出<code>script start</code>，执行结束后把它移出 Call Stack</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop05.png" alt="js-eventloop05"></p><p>4，把 setTimeout 放到 Call Stack</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop06.png" alt="js-eventloop06"></p><p>5, 执行 setTimeout，用 setTimout 线程执行 timeout 时间，Call Stack 中 setTimeout 执行结束，把它移出 Call Stack</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop07.png" alt="js-eventloop07"></p><p>6, 把<code>console.log(&#39;script end&#39;)</code>加到 Call Stack</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop08.png" alt="js-eventloop08"></p><p>7，执行<code>console.log(&#39;script end&#39;)</code>，在 console 里打印出<code>script end</code></p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop09.png" alt="js-eventloop09"></p><p>8，<code>console.log(&#39;script end&#39;)</code>执行结束，把它移出 Call Stack</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop10.png" alt="js-eventloop10"></p><p>9，1000 毫秒以后，计时结束，把 callback<code>cb1</code>函数放到 Callback Queue 里</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop11.png" alt="js-eventloop11"></p><p>10，此时 Callback Stack 是空的，Event Loop 把 cb1 拿到 Callback Stack 里</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop12.png" alt="js-eventloop12"></p><p>11，执行 cb1，cb1 里有<code>console.log(&#39;setTimeout&#39;)</code>，把<code>console.log(&#39;setTimeout&#39;)</code>放到 Call Stack 里</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop13.png" alt="js-eventloop13"></p><p>12，执行<code>console.log(&#39;setTimeout&#39;)</code>，在 console 里打印出<code>setTimeout</code>，<code>console.log(&#39;setTimeout&#39;)</code>执行结束，把它移出 Call Stack</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop14.png" alt="js-eventloop14"></p><p>13，<code>cb1</code>执行结束，把它移出 Call Stack</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop15.png" alt="js-eventloop15"></p><p>总结来说就是，JS 是单线程的，只有一个 Call Stack，浏览器是多线程的，并且 DOM 事件、AJAX(XMLHttpRequest)、setTimeout 都是有单独的线程处理。在这些异步事件结束，runtime 会把它们的 callback 按顺序放到 Callback Queue 里，Event Loop 会检测 Call Stack，一旦它为空，就会把 Callback Queue 里的回调函数依次放到 Call Stack 里执行，直到 Callback Queue 为空。</p><h2 id="microtasks-和-macrotask-的执行顺序"><a href="#microtasks-和-macrotask-的执行顺序" class="headerlink" title="microtasks 和 macrotask 的执行顺序"></a>microtasks 和 macrotask 的执行顺序</h2><p>刚才用 setTimeout 为例，解释了 JS 中 Event Loop 机制是怎么运行的，也提到过 runtime 会把回调函数依次按时间先后顺序放到 Callback Queue 里，然后 Event Loop 再依次把这些回调函数放到 Call Stack 里运行。我们在浏览器 Console 运行以下代码，看下结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">script</span> start</span><br><span class="line"><span class="keyword">script</span> <span class="keyword">end</span></span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure><blockquote><p>上述代码虽然 setTimeout 延时为0，其实还是异步的。因为H5标准规定 setTimeout 函数的第二个参数不能小于4毫秒，不足会自动增加。</p></blockquote><p>setTimeout 和 promise 都是异步事件，而且 setTimeout 写在 promise 之前，为什么 setTimeout 的回调要比 promise 后执行呢？那是因为 promise 属于微任务（microtasks）而 setTimeout 属于宏任务（macrotask），微任务（microtasks）的优先级要高于宏任务（macrotask）。</p><p>首先我们需要明白以下几件事情：</p><ul><li>JS 分为同步任务和异步任务</li><li>同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li><li>一旦执行栈中的所有同步任务执行完毕（此时 JS 引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。</li></ul><p>根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout/Promise 等 API 便是任务源，而进入任务队列的是他们指定的具体执行任务。</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop16.png" alt="js-eventloop16"></p><p>Callback Queue（Task Queue）里的回调事件称为宏任务（macrotask），每次异步事件结束后，它们的回调函数会依次按时间顺序放在 Callback Queue 里，等待 Event Loop 依次把它们放到 Call Stack 里执行。比如：<code>setInterval</code> <code>setTimeout</code> <code>script</code> <code>setImmediate</code> <code>I/O</code> <code>UI rendering</code>就是宏任务（macrotask）。</p><p>微任务（microtasks）是指异步事件结束后，回调函数不会放到 Callback Queue，而是放到一个微任务队列里（Microtasks Queue），在 Call Stack 为空时，Event Loop 会先查看微任务队列里是否有任务，如果有就会先执行微任务队列里的回调事件；如果没有微任务，才会到 Callback Queue 执行回到事件。比如：<code>promise</code> <code>process.netTick</code> <code>Object.observe</code> <code>MutationObserver</code>就是微任务（microtasks）。</p><blockquote><p>在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。</p></blockquote><p>整个 Event Loop 的执行顺序如下：</p><ul><li>执行一个宏任务（栈中没有就从事件队列中获取）</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li><li>当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染</li><li>渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取，也就是 callbacke queue）</li></ul><p>流程图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/js-eventloop17.jpg" alt="js-eventloop17"></p><p>我们再把代码改一下，在创建 promise 的时候，加一行<code>console.log(&#39;Promise&#39;)</code>，而且在第一个 promise resolve 的时候再加一个 setTimeout，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Promise&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout in promise1&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">Promise</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">setTimeout in promise1</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p><code>console.log(&#39;Promise&#39;)</code>在这里是同步代码，<code>console.log(&#39;script end&#39;)</code>是同步代码且放在最后，所以<code>Promise</code>在<code>script end</code>前面，而且在微任务（microtasks）里有宏任务（macrotask），macrotask 还是会依次被放到 Callback Queue 等待执行。</p><p>如果有 async await 呢？再来看一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请写出输出内容</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">async1 start</span></span><br><span class="line"><span class="comment">async2</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">async1 end</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>我们知道 Promise 中的异步体现在 then 和 catch 中，所以写在 Promise 中的代码是被当做同步任务立即执行的。而在 async/await 中，在出现 await 出现之前，其中的代码也是立即执行的。那么出现了 await 时候发生了什么呢？</p><p>由于因为 async await 本身就是 promise+generator 的语法糖。所以 await 后面的代码是 microtask。所以对于上面代码中的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(async2()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一个变式, 将 async2 中的函数也变成了 Promise 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//async2做出如下更改：</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise3&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise4&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">async1 start</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">promise3</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">async1 end</span></span><br><span class="line"><span class="comment">promise4</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>我们再来看一个变式，将 async1 中 await 后面的代码和 async2 的代码都改为异步的，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="comment">//更改如下：</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout1&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//更改如下：</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout2&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout3&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">async1 start</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">setTimeout3</span></span><br><span class="line"><span class="comment">setTimeout2</span></span><br><span class="line"><span class="comment">setTimeout1</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>我们再来看一个变式，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> a2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">a2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">a1();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&quot;promise2.then&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise2.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;promise3&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">a1 start</span></span><br><span class="line"><span class="comment">a2</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">a1 end</span></span><br><span class="line"><span class="comment">promise2.then</span></span><br><span class="line"><span class="comment">promise3</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JavaScript-详解-Event-Loop-运行机制&quot;&gt;&lt;a href=&quot;#JavaScript-详解-Event-Loop-运行机制&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 详解 Event Loop 运行机制&quot;&gt;&lt;/a&gt;JavaScript 详解 Event Loop 运行机制&lt;/h1&gt;&lt;p&gt;在这篇文章中会介绍以下内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;engine runtime 和 call stack 简介（以 V8 引擎为例）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Event Loop 运行机制的详解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;microtasks 和 macrotask 的执行顺序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;engine-runtime-和-call-stack-简介&quot;&gt;&lt;a href=&quot;#engine-runtime-和-call-stack-简介&quot; class=&quot;headerlink&quot; title=&quot;engine runtime 和 call stack 简介&quot;&gt;&lt;/a&gt;engine runtime 和 call stack 简介&lt;/h2&gt;&lt;p&gt;在 chrome 浏览器和 nodejs 里都是用 V8 引擎解析和运行 JS 代码，我们先来看下 V8 引擎的简化图：&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 深浅拷贝</title>
    <link href="http://example.com/2021/07/17/JavaScript%20%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://example.com/2021/07/17/JavaScript%20%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2021-07-17T09:25:35.000Z</published>
    <updated>2022-07-27T07:25:27.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-深浅拷贝"><a href="#JavaScript-深浅拷贝" class="headerlink" title="JavaScript 深浅拷贝"></a>JavaScript 深浅拷贝</h1><p>我们先来看下数组的拷贝，通常我们会用<code>slice()</code> <code>concat()</code>方法实现数组拷贝：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.concat();</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.slice();</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><span id="more"></span><p><code>slice()</code> <code>concat()</code>都是返回了一个新数组，没有改变原来的数组，看起来像是深拷贝。</p><p>我们再来看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#123; <span class="attr">value</span>: <span class="number">5</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr.concat();</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.slice();</span><br><span class="line">arr[<span class="number">4</span>].value = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">//[1, 2, 3, 4, &#123; value: 6 &#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//[1, 2, 3, 4, &#123; value: 6 &#125;]</span></span><br></pre></td></tr></table></figure><p>这边可以看到，如果数组里有对象，那么不会拷贝对象的值，而是拷贝对象的引用，原来数据对象的值发生改变，由于拷贝的是对象的引用，新拷贝的数组中对象的值也发生改变，拷贝的不是很彻底，<code>slice()</code> <code>concat()</code>是<strong>浅拷贝</strong>，对于对象，我们通常通过<code>assign()</code>或者展开运算符<code>...</code>来实现拷贝，同样如果对象里嵌套了对象，也只能实现浅拷贝：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;fuck&quot;</span>,</span><br><span class="line">  address: &#123; <span class="attr">city</span>: <span class="string">&quot;shanghai&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; ...obj &#125;;</span><br><span class="line">obj.address.city = <span class="string">&quot;beijing&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123;name: &quot;fuck&quot;, address:&#123;city: &quot;beijing&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">//&#123;name: &quot;fuck&quot;, address:&#123;city: &quot;beijing&quot;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="利用-JSON-stringify-实现对数组和对象的深拷贝"><a href="#利用-JSON-stringify-实现对数组和对象的深拷贝" class="headerlink" title="利用 JSON.stringify 实现对数组和对象的深拷贝"></a>利用 JSON.stringify 实现对数组和对象的深拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#123; <span class="attr">value</span>: <span class="number">5</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br><span class="line">arr[<span class="number">4</span>].value = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">//[1, 2, 3, 4, &#123; value: 5 &#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;fuck&quot;</span>,</span><br><span class="line">  address: &#123; <span class="attr">city</span>: <span class="string">&quot;shanghai&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">obj.address.city = <span class="string">&quot;beijing&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123;name: &quot;fuck&quot;, address:&#123;city: &quot;shanghai&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>该方法不能对<code>undefined</code> <code>symbol</code> <code>函数</code> 进行深度拷贝。</p><h2 id="利用递归实现数组和对象深拷贝"><a href="#利用递归实现数组和对象深拷贝" class="headerlink" title="利用递归实现数组和对象深拷贝"></a>利用递归实现数组和对象深拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObj[key] =</span><br><span class="line">        <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span> ? deepCopy(obj[key]) : obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来验证下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#123; <span class="attr">value</span>: <span class="number">5</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> arr2 = deepCopy(arr);</span><br><span class="line">arr[<span class="number">4</span>].value = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//1, 2, 3, 4, &#123; value: 6 &#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//1, 2, 3, 4, &#123; value: 5 &#125;]</span></span><br></pre></td></tr></table></figure><p>对于数组和对象的浅拷贝，去掉递归就可以了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> newObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObj[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, &#123; <span class="attr">value</span>: <span class="number">5</span> &#125;];</span><br><span class="line"><span class="keyword">var</span> arr2 = shallowCopy(arr);</span><br><span class="line">arr[<span class="number">4</span>].value = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//1, 2, 3, 4, &#123; value: 6 &#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">//1, 2, 3, 4, &#123; value: 6 &#125;]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JavaScript-深浅拷贝&quot;&gt;&lt;a href=&quot;#JavaScript-深浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 深浅拷贝&quot;&gt;&lt;/a&gt;JavaScript 深浅拷贝&lt;/h1&gt;&lt;p&gt;我们先来看下数组的拷贝，通常我们会用&lt;code&gt;slice()&lt;/code&gt; &lt;code&gt;concat()&lt;/code&gt;方法实现数组拷贝：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr1 = arr.concat();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr2 = arr.slice();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr1); &lt;span class=&quot;comment&quot;&gt;//[1, 2, 3, 4, 5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr2); &lt;span class=&quot;comment&quot;&gt;//[1, 2, 3, 4, 5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript let和const</title>
    <link href="http://example.com/2021/07/16/JavaScript%20let%E5%92%8Cconst/"/>
    <id>http://example.com/2021/07/16/JavaScript%20let%E5%92%8Cconst/</id>
    <published>2021-07-16T05:35:15.000Z</published>
    <updated>2022-07-27T07:16:29.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-let-和-const"><a href="#JavaScript-let-和-const" class="headerlink" title="JavaScript let 和 const"></a>JavaScript let 和 const</h1><p>在 JS 中用 var 声明变量存在变量提升，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>这段代码输出的是 undefined，而不是 ReferenceError。这是因为 var 有变量提升，实际这段代码相当于：</p><span id="more"></span><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>还有在 for 循环中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  result.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]()); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>]()); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">2</span>]()); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">3</span>]()); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">4</span>]()); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>数组里输出的值都是 5，并且 for 循环结束了，还是可以访问 i 的值。在 ES6 之前，是没有块级作用域，在 ES6 中引入了块级作用域，块级作用域是指：</p><ul><li>函数内部</li><li>块中(字符 { 和 } 之间的区域)</li></ul><h2 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h2><p>let 和 const 是用来声明块级作用域变量，它们有以下特性：</p><h3 id="1-不会被提升"><a href="#1-不会被提升" class="headerlink" title="1. 不会被提升"></a>1. 不会被提升</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//Uncaught ReferenceError: a is not defined</span></span><br></pre></td></tr></table></figure><h3 id="2-重复声明会报错"><a href="#2-重复声明会报错" class="headerlink" title="2. 重复声明会报错"></a>2. 重复声明会报错</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span>; <span class="comment">//Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><h3 id="3-不绑定全局作用域"><a href="#3-不绑定全局作用域" class="headerlink" title="3. 不绑定全局作用域"></a>3. 不绑定全局作用域</h3><p>在全局作用就里使用<code>var</code>声明变量或者 <code>function</code>(只用这两种形式)，这个变量会作为全局对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>但是用 let 和 const 不会：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h3 id="let-和-const-的区别"><a href="#let-和-const-的区别" class="headerlink" title="let 和 const 的区别"></a>let 和 const 的区别</h3><p>const 用来声明常量，一旦初始化，就不能再被修改，否则会报错。<br>但是对于 const 声明的对象，对象的引用不能被修改，但是对象里的属性值是可以被修改的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">data.a = <span class="number">2</span>; <span class="comment">//可以被修改</span></span><br><span class="line">data.b = <span class="number">3</span>; <span class="comment">//会加一个属性b</span></span><br><span class="line"></span><br><span class="line">data = &#123;&#125;; <span class="comment">//报错：Uncaught TypeError: Assignment to constant variable</span></span><br></pre></td></tr></table></figure><h3 id="暂时性死区-Temporal-Dead-Zone"><a href="#暂时性死区-Temporal-Dead-Zone" class="headerlink" title="暂时性死区(Temporal Dead Zone)"></a>暂时性死区(Temporal Dead Zone)</h3><p>在 JS 引擎扫描代码发现变量声明时，遇到 var 声明就提升到作用域顶部，遇到 let 和 const 就把这些声明放在暂时性死区。对于 let 和 const 变量，如果在执行它们的声明语句之前访问会报错，只有执行完声明语句之后才会从暂时性死区移出。</p><blockquote><p>The time between entering the scope of a variable and executing its declaration is called the temporal dead zone (TDZ) of that variable.</p><p>During this time, the variable is considered to be uninitialized (as if that were a special value it has).</p><p>If you access an uninitialized variable, you get a ReferenceError.</p><p>Once you reach a variable declaration, the variable is set to either the value of the initializer (specified via the assignment symbol) or undefined – if there is no initializer.</p></blockquote><p>需要注意的是 let const 会变量提升，但是在执行声明语句之前，是放在暂时性死区，提前调用就会报错；想象一下如果 let const 没有变量提升的话，在声明之前调用 let const 变量，就会当成<code>var = halo</code>处理了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saySomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  greeting = <span class="string">&quot;halo&quot;</span>; <span class="comment">// Uncaught ReferenceError: Cannot access &#x27;greeting&#x27; before initialization</span></span><br><span class="line">  <span class="keyword">let</span> greeting;</span><br><span class="line">  <span class="built_in">console</span>.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line">saySomething();</span><br></pre></td></tr></table></figure><h3 id="循环中的块级作用域"><a href="#循环中的块级作用域" class="headerlink" title="循环中的块级作用域"></a>循环中的块级作用域</h3><p>之前有代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  result.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]()); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>]()); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">2</span>]()); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">3</span>]()); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">4</span>]()); <span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>我们实际想要的输出 0 1 2 3 4，解决方案有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  result.push(</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;)(i)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]()); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>]()); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">2</span>]()); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">3</span>]()); <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">4</span>]()); <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>还可以用 ES6 中的 let：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  result.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">0</span>]()); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">1</span>]()); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">2</span>]()); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">3</span>]()); <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(result[<span class="number">4</span>]()); <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>之前说过，let 不提升，不能重复定义，在第二次循环的时候，又用 let 声明了 i，为什么在这里不报错，可以正确输出值呢？<br>比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会输出三个 abc，但是用 var：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只会输出一个 abc。</p><p>JS 引擎对 var 和 let 使用了不同的方式处理，对于 let 每次循环都会创建一个新变量，对于代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  result.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">let</span> i = <span class="number">0</span>) &#123;</span><br><span class="line">    result[<span class="number">0</span>]= <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">0</span>) &#125;;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">let</span> i = <span class="number">1</span>) &#123;</span><br><span class="line">    result[<span class="number">1</span>]= <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="keyword">let</span> i = <span class="number">2</span>) &#123;</span><br><span class="line">    result[<span class="number">2</span>]= <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>) &#125;;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">(<span class="keyword">let</span> i = <span class="number">4</span>) &#123;</span><br><span class="line">    result[<span class="number">4</span>]= <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">4</span>) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在上面代码里不能用 const，虽然我们每次创建了一个新的变量，但是我们尝试修改 const 的值，所以会报错</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在开发过程中，默认推荐使用 const，只有当确定变量的值会发生改变使用 let</li><li>函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部</li><li>var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用</li><li>var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会</li><li>let 和 const 作用基本一致，但是后者声明的变量不能再次赋值</li><li>只有 var 函数 有变量提升，其他的 class let const import 都没有变量提升， 如果函数表达式是 let const 也不会变量提升</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JavaScript-let-和-const&quot;&gt;&lt;a href=&quot;#JavaScript-let-和-const&quot; class=&quot;headerlink&quot; title=&quot;JavaScript let 和 const&quot;&gt;&lt;/a&gt;JavaScript let 和 const&lt;/h1&gt;&lt;p&gt;在 JS 中用 var 声明变量存在变量提升，比如：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a); &lt;span class=&quot;comment&quot;&gt;//undefined&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这段代码输出的是 undefined，而不是 ReferenceError。这是因为 var 有变量提升，实际这段代码相当于：&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 箭头函数</title>
    <link href="http://example.com/2021/07/16/JavaScript%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/07/16/JavaScript%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</id>
    <published>2021-07-16T04:01:20.000Z</published>
    <updated>2022-07-27T07:05:09.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-箭头函数"><a href="#JavaScript-箭头函数" class="headerlink" title="JavaScript 箭头函数"></a>JavaScript 箭头函数</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>ES6 中箭头函数的基本语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">value</span>) =&gt;</span> value;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><p>如果需要传入多个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">value, num</span>) =&gt;</span> value * num;</span><br></pre></td></tr></table></figure><p>上面箭头函数例子中都省略了<code>return</code>关键字和代码的花括号，在箭头函数中如果方法体中只有一行代码，可以省略关键字和方法体的花括号，直接简化成<code>value =&gt; value</code>。</p><p>如果函数的代码块需要有多条语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">value, num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> value * num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果需要返回一个对象，箭头函数的方法体必须放在大括号<code>()</code>中，这样做的原因是：没有大括号，JS 引擎没办分区分是正常定义一个对象还是一个箭头函数体:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">value, num</span>) =&gt;</span> (&#123; <span class="attr">value</span>: value, <span class="attr">num</span>: num &#125;); <span class="comment">//正确写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">value, num</span>) =&gt;</span> &#123; <span class="attr">value</span>: value, <span class="attr">num</span>: num &#125;; <span class="comment">//会报错</span></span><br></pre></td></tr></table></figure><h2 id="与普通函数的区别"><a href="#与普通函数的区别" class="headerlink" title="与普通函数的区别"></a>与普通函数的区别</h2><h3 id="1-没有-this"><a href="#1-没有-this" class="headerlink" title="1.没有 this"></a>1.没有 this</h3><p>箭头函数式的 this 需要通过查找作用域链来确定，它的 this 是指包在它外面的作用域的 this，我们来看下以下代码中的 this 分别指的是什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// obj</span></span><br><span class="line">  &#125;,</span><br><span class="line">  b: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// windows</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>obj.b 是一个箭头函数，它的 this 是包在它外层的词法作用域的 this（离它最近的词法作用域），obj 对象不是可执行代码，所以它不是离箭头函数最近的词法作用域，再往外就是全局作用域 window 了，所以 obj.b 的 this 指的是 windows。</p><p>再来看一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageHandler = &#123;</span><br><span class="line">  id: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(</span><br><span class="line">      <span class="string">&quot;click&quot;</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.doSomething(event.type); <span class="comment">// error</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Handling &quot;</span> + type + <span class="string">&quot; for &quot;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在调用<code>pageHandler.init</code>方法的时候会报错，报错的函数是个回调函数，这个回调函数的 this 指的全局变量 windows，在全局变量里没有 doSomething 这个方法，所以会报错。那么怎么才能让它不报错呢？</p><p>第一种方式是通过 bind 来指定 this：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageHandler = &#123;</span><br><span class="line">  id: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(</span><br><span class="line">      <span class="string">&quot;click&quot;</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.doSomething(event.type);</span><br><span class="line">      &#125;.bind(<span class="built_in">this</span>),</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Handling&quot;</span> + type + <span class="string">&quot; for &quot;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>.bind(this)中的 this 是指 pageHandler 这个对象，通过 bind 生成一个 this 指向 pageHandler 的新函数，这样执行 init 方法的时候不会报错，看起来怪怪的有没有。</p><p>第二种方式是通过箭头函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pageHandler = &#123;</span><br><span class="line">  id: <span class="string">&quot;12345&quot;</span>,</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(</span><br><span class="line">      <span class="string">&quot;click&quot;</span>,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        <span class="built_in">this</span>.doSomething();</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Handling&quot;</span> + type + <span class="string">&quot; for &quot;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把 init 中的回调函数改成了箭头函数，箭头函数的 this 是它最近的作用域链上的 this，也就是 init 这个方法的 this，也就是 pageHandler 这个对象，这样就可以达到目的不报错啦。</p><p><strong>需要注意的是，箭头函数不能改变 this 的值，普通函数可以通过 call、apply、bind 来指定 this，但是箭头函数的 this 是不能改的。</strong></p><h3 id="2-没有-arguments"><a href="#2-没有-arguments" class="headerlink" title="2.没有 arguments"></a>2.没有 arguments</h3><p>访问箭头函数的 arguments，其实也是访问包在它外面的非箭头函数的 arguments。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">1</span>, <span class="number">2</span>)()); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h3 id="3-不能通过-new-关键字调用。"><a href="#3-不能通过-new-关键字调用。" class="headerlink" title="3.不能通过 new 关键字调用。"></a>3.不能通过 new 关键字调用。</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(); <span class="comment">// TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure><h3 id="4-没有原型"><a href="#4-没有原型" class="headerlink" title="4.没有原型"></a>4.没有原型</h3><p>没有<code>prototype</code>, 但是有<code>__proto__</code>指向 function。</p><h3 id="5-没有-super，也是通过包在它外面的非箭头函数来决定的。"><a href="#5-没有-super，也是通过包在它外面的非箭头函数来决定的。" class="headerlink" title="5.没有 super，也是通过包在它外面的非箭头函数来决定的。"></a>5.没有 super，也是通过包在它外面的非箭头函数来决定的。</h3>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JavaScript-箭头函数&quot;&gt;&lt;a href=&quot;#JavaScript-箭头函数&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 箭头函数&quot;&gt;&lt;/a&gt;JavaScript 箭头函数&lt;/h1&gt;&lt;h2 id=&quot;基本语法&quot;&gt;&lt;a href=&quot;#基本语法&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h2&gt;&lt;p&gt;ES6 中箭头函数的基本语法：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; func = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) =&amp;gt;&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;相当于：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; func = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://example.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack高级优化</title>
    <link href="http://example.com/2021/06/16/Webpack%E9%AB%98%E7%BA%A7%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/06/16/Webpack%E9%AB%98%E7%BA%A7%E4%BC%98%E5%8C%96/</id>
    <published>2021-06-16T14:25:40.000Z</published>
    <updated>2022-06-23T05:56:12.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Webpack高级优化"><a href="#Webpack高级优化" class="headerlink" title="Webpack高级优化"></a>Webpack高级优化</h1><h2 id="提升开发体验"><a href="#提升开发体验" class="headerlink" title="提升开发体验"></a>提升开发体验</h2><h3 id="sourcemap"><a href="#sourcemap" class="headerlink" title="sourcemap"></a>sourcemap</h3><ol><li><p>打包完后的代码不便与阅读</p></li><li><p>因此需要sourcemap来生成源代码与构建后代码的一一映射</p></li><li><p>会生成xxx.map文件，包含源代码与构建后代码每一行，每一列的映射关系</p><ol><li>如果构建代码出错，通过xxx.map文件可以定位到源代码出错位置</li></ol></li><li><p>使用</p></li></ol><span id="more"></span><ol><li><p>开发模式</p><ol><li><p><code>cheap-module-source-map</code></p><ul><li><p>优点：打包编译快，只含行映射</p></li><li><p>缺点：没有列映射</p></li><li><pre><code class="javascript">module.exports = &#123;  // 其他省略  mode: &quot;development&quot;,  devtool: &quot;cheap-module-source-map&quot;,&#125;;<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2</span>. 生产模式</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. `source-map`</span><br><span class="line"></span><br><span class="line">      - 优点：包含行/列映射 （生产模式打包后的代码时是压缩为一行的，没有列映射很难定位出错位置）</span><br><span class="line"></span><br><span class="line">      - 缺点：打包编译速度更慢</span><br><span class="line"></span><br><span class="line">      - ```javascript</span><br><span class="line">        module.exports = &#123;</span><br><span class="line">          // 其他省略</span><br><span class="line"><span class="title">          mode:</span> <span class="string">&quot;production&quot;</span>,</span><br><span class="line"><span class="title">          devtool:</span> <span class="string">&quot;source-map&quot;</span>,</span><br><span class="line">        &#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ol></li></ol><h2 id="提升打包构建速度"><a href="#提升打包构建速度" class="headerlink" title="提升打包构建速度"></a>提升打包构建速度</h2><h4 id="HotModuleReplacement"><a href="#HotModuleReplacement" class="headerlink" title="HotModuleReplacement"></a>HotModuleReplacement</h4><ol><li><p>开发过程中，我们修改了一个模块的代码，webpack默认将所有模块重新编译打包，速度很慢</p><ul><li>因此我们只需要对修改的模块重新编译打包，其他模块不变就可以提升打包速度</li></ul></li><li><p>HotModuleReplacement（HMR/热模块替换）：在程序运行中，替换、添加或删除模块，而无需重新加载整个页面</p></li><li><p>配置</p><ol><li><pre><code class="javascript">module.exports = &#123;  // 其他省略  devServer: &#123;    host: &quot;localhost&quot;, // 启动服务器域名    port: &quot;3000&quot;, // 启动服务器端口号    open: true, // 是否自动打开浏览器    hot: true, // 开启HMR功能（只能用于开发环境，生产环境不需要了）  &#125;,&#125;;<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="number">2</span>. 可以在js中判断是否支持hmr，但是会非常麻烦</span><br><span class="line"></span><br><span class="line">      - ![image-<span class="number">20220607180103928</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607180103928</span>.png)</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span>. 实际开发过程中用loader来解决</span><br><span class="line"></span><br><span class="line">      - React-hot-loader</span><br><span class="line"></span><br><span class="line"><span class="comment">### OneOf</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 打包过程中，每个文件会经过所有loader处理，虽然正则没有匹配上，但是都需要经过一遍，浪费时间</span><br><span class="line"><span class="number">2</span>. 使用oneof：只要有一个匹配上了就不进行多余操作</span><br><span class="line"><span class="number">3</span>. 配置webpack</span><br><span class="line">   - ![image-<span class="number">20220607182231155</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607182231155</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Include/Exclude</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 开发过程中我们需要使用第三方库或者插件，这些文件都会下载到node_module文件夹中</span><br><span class="line">   - 这些文件是不需要编译就可以使用的</span><br><span class="line">   - 因此我们在编译js的时候要排除node_module</span><br><span class="line"><span class="number">2</span>. 配置webpack</span><br><span class="line">   <span class="number">1</span>. ![image-<span class="number">20220607182501230</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607182501230</span>.png)</span><br><span class="line">   <span class="number">2</span>. ![image-<span class="number">20220607182527569</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607182527569</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Cache</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 每次打包都需要经过Eslint检查以及babel编译，速度慢</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 我们可以缓存eslint检查和babel的编译结果，这样在第二次打包的速度就更快了</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 配置webpack （缓存文件不要压缩，可以提高检索效率）</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. ```javascript</span><br><span class="line">      options: &#123;</span><br><span class="line">                    cacheDirectory: true, <span class="regexp">//</span> 开启babel编译缓存</span><br><span class="line">                    cacheCompression: false, <span class="regexp">//</span> 缓存文件不要压缩</span><br><span class="line">                  &#125;,</span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="javascript">cache: true, // 开启缓存      // 缓存目录      cacheLocation: path.resolve(        __dirname,        &quot;../node_modules/.cache/.eslintcache&quot;      ),<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="number">3</span>. ![image-<span class="number">20220607182755181</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607182755181</span>.png)</span><br><span class="line"></span><br><span class="line">   <span class="number">4</span>. ![image-<span class="number">20220607182839166</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607182839166</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Thread</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 项目越庞大，打包速度越慢</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 对js文件的处理主要是eslint，babel，terser三个工具，所以我们要提升他们的速度</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 开启多进程同时处理js</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. 配置webpack</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. 获取cpu的核数</span><br><span class="line"></span><br><span class="line">      - ```javascript</span><br><span class="line">        <span class="regexp">//</span> nodejs核心模块，直接使用</span><br><span class="line">        const os = require(<span class="string">&quot;os&quot;</span>);</span><br><span class="line">        <span class="regexp">//</span> cpu核数</span><br><span class="line">        const threads = os.cpus().length;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>下载包 <code>npm i thread-loader -D</code></p></li><li><pre><code class="javascript">use: [              &#123;                loader: &quot;thread-loader&quot;, // 开启多进程                options: &#123;                  workers: threads, // 数量                &#125;,              &#125;,              &#123;                loader: &quot;babel-loader&quot;,                options: &#123;                  cacheDirectory: true, // 开启babel编译缓存                &#125;,              &#125;,            ],<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">   4.</span> ![<span class="string">image-20220607193846738</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607193846738.png</span>)</span><br><span class="line"><span class="bullet">   5.</span> ![<span class="string">image-20220607193819516</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607193819516.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">   6.</span> ![<span class="string">image-20220607193928589</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607193928589.png</span>)</span><br><span class="line"><span class="bullet">   7.</span> 项目较小的时候开多线程打包速度反而变慢，因为开启线程也是耗时操作，因此只有项目到达一定大小的时候开启多线程才能提高打包速度</span><br><span class="line"></span><br><span class="line"><span class="section">## 减少代码体积</span></span><br><span class="line"></span><br><span class="line"><span class="section">### Tree Shaking</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 开发过程中我们定义了一些工具函数库，或者使用了第三方的工具库或者组件库</span><br><span class="line"><span class="bullet">   -</span> 如果没有特殊处理，当我们只使用了一小部分功能时，打包却要引入整个库，这无疑会增大打包后的体积</span><br><span class="line"><span class="bullet">2.</span> tree shaking 是个术语，用于描述移除js中没有使用上的代码</span><br><span class="line"><span class="bullet">   -</span> 依赖于es module</span><br><span class="line"><span class="bullet">3.</span> webpack默认开启该功能，无需其他配置</span><br><span class="line"></span><br><span class="line"><span class="section">### Babel</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> babel在编译时为每个文件都插入了辅助代码，使代码体积过大</span><br><span class="line"><span class="bullet">2.</span> 可以将这些辅助代码作为一个独立的模块，避免重复引入</span><br><span class="line"><span class="bullet">3.</span> 配置webpack</span><br><span class="line"><span class="bullet">   1.</span> 下载包 <span class="code">`npm i @babel/plugin-transform-runtime -D`</span></span><br><span class="line"><span class="bullet">   2.</span> <span class="code">`@babel/plugin-transform-runtime`</span>可以禁用babel的自动引入</span><br><span class="line"><span class="bullet">   3.</span> ![<span class="string">image-20220607195613506</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607195613506.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### Image Minimizer</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果项目中有很多图片，那么打包后图片体积会很大，请求速度会慢</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> 因此需要对图片进行压缩，减少图片体积</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 配置webpack</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> 下载包 <span class="code">`npm i image-minimizer-webpack-plugin imagemin -D`</span></span><br><span class="line"><span class="bullet">      1.</span> 无损压缩</span><br><span class="line"><span class="bullet">         -</span> <span class="code">`npm install imagemin-gifsicle imagemin-jpegtran imagemin-optipng imagemin-svgo -D`</span></span><br><span class="line"><span class="bullet">      2.</span> 有损压缩</span><br><span class="line"><span class="bullet">         -</span> <span class="code">`npm install imagemin-gifsicle imagemin-mozjpeg imagemin-pngquant imagemin-svgo -D`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   2.</span> <span class="code">```javascript</span></span><br><span class="line"><span class="code">      const ImageMinimizerPlugin = require(&quot;image-minimizer-webpack-plugin&quot;);</span></span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="javascript">// 压缩图片      new ImageMinimizerPlugin(&#123;        minimizer: &#123;          implementation: ImageMinimizerPlugin.imageminGenerate,          options: &#123;            plugins: [              [&quot;gifsicle&quot;, &#123; interlaced: true &#125;],              [&quot;jpegtran&quot;, &#123; progressive: true &#125;],              [&quot;optipng&quot;, &#123; optimizationLevel: 5 &#125;],              [                &quot;svgo&quot;,                &#123;                  plugins: [                    &quot;preset-default&quot;,                    &quot;prefixIds&quot;,                    &#123;                      name: &quot;sortAttrs&quot;,                      params: &#123;                        xmlnsOrder: &quot;alphabetical&quot;,                      &#125;,                    &#125;,                  ],                &#125;,              ],            ],          &#125;,        &#125;,      &#125;),<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="number">4</span>. ![image-<span class="number">20220607200319039</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607200319039</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 优化代码性能</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Code split</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 打包代码会把所有代码打包到一个文件中，体积太大</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. 如果我们只需要渲染首页，就应该只加载首页的js文件</span><br><span class="line">   <span class="number">2</span>. 所以我们在打包的时候对文件进行代码分割，生成多个js文件，渲染哪个页面就只加载某个js文件</span><br><span class="line">   <span class="number">3</span>. 这样加载的资源少，速度就快</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. code split主要做两件事</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. 分割文件：将打包生成的文件进行分割，生成多个js文件</span><br><span class="line">   <span class="number">2</span>. 按需加载：需要哪个文件就加载哪个文件</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 多入口</span><br><span class="line"></span><br><span class="line">   - 多个入口文件</span><br><span class="line">   - ![image-<span class="number">20220607202046597</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607202046597</span>.png)</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. 下载包 `npm i webpack webpack-cli html-webpack-plugin -D`</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span>. 配置webpack</span><br><span class="line"></span><br><span class="line">      - ```javascript</span><br><span class="line">        <span class="regexp">//</span> webpack.config.js</span><br><span class="line">        const path = require(<span class="string">&quot;path&quot;</span>);</span><br><span class="line">        const HtmlWebpackPlugin = require(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        module.exports = &#123;</span><br><span class="line">          <span class="regexp">//</span> 单入口</span><br><span class="line">          <span class="regexp">//</span> entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">          <span class="regexp">//</span> 多入口</span><br><span class="line">          entry: &#123;</span><br><span class="line">            main: <span class="string">&quot;./src/main.js&quot;</span>,</span><br><span class="line">            app: <span class="string">&quot;./src/app.js&quot;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">          output: &#123;</span><br><span class="line">            path: path.resolve(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">            <span class="regexp">//</span> [name]是webpack命名规则，使用chunk的name作为输出的文件名。</span><br><span class="line">            <span class="regexp">//</span> 什么是chunk？打包的资源就是chunk，输出出去叫bundle。</span><br><span class="line">            <span class="regexp">//</span> chunk的name是啥呢？ 比如： entry中xxx: <span class="string">&quot;./src/xxx.js&quot;</span>, name就是xxx。注意是前面的xxx，和文件名无关。</span><br><span class="line">            <span class="regexp">//</span> 为什么需要这样命名呢？如果还是之前写法main.js，那么打包生成两个js文件都会叫做main.js会发生覆盖。(实际上会直接报错的)</span><br><span class="line">            filename: <span class="string">&quot;js/[name].js&quot;</span>,</span><br><span class="line">            clear: true,</span><br><span class="line">          &#125;,</span><br><span class="line">          plugins: [</span><br><span class="line">            new HtmlWebpackPlugin(&#123;</span><br><span class="line">              template: <span class="string">&quot;./public/index.html&quot;</span>,</span><br><span class="line">            &#125;),</span><br><span class="line">          ],</span><br><span class="line">          mode: <span class="string">&quot;production&quot;</span>,</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>- ```javascript    optimization: &#123;      // 代码分割配置      splitChunks: &#123;        chunks: &quot;all&quot;, // 对所有模块都进行分割        // 以下是默认值        // minSize: 20000, // 分割代码最小的大小        // minRemainingSize: 0, // 类似于minSize，最后确保提取的文件大小不能为0        // minChunks: 1, // 至少被引用的次数，满足条件才会代码分割        // maxAsyncRequests: 30, // 按需加载时并行加载的文件的最大数量        // maxInitialRequests: 30, // 入口js文件最大并行请求数量        // enforceSizeThreshold: 50000, // 超过50kb一定会单独打包（此时会忽略minRemainingSize、maxAsyncRequests、maxInitialRequests）        // cacheGroups: &#123; // 组，哪些模块要打包到一个组        //   defaultVendors: &#123; // 组名        //     test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块        //     priority: -10, // 权重（越大越高）        //     reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块        //   &#125;,        //   default: &#123; // 其他没有写的配置会使用上面的默认值        //     minChunks: 2, // 这里的minChunks权重更大        //     priority: -20,        //     reuseExistingChunk: true,        //   &#125;,        // &#125;,        // 修改配置        cacheGroups: &#123;          // 组，哪些模块要打包到一个组          // defaultVendors: &#123; // 组名          //   test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块          //   priority: -10, // 权重（越大越高）          //   reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块          // &#125;,          default: &#123;            // 其他没有写的配置会使用上面的默认值            minSize: 0, // 我们定义的文件体积太小了，所以要改打包的最小文件体积            minChunks: 2,            priority: -20,            reuseExistingChunk: true,          &#125;,        &#125;,      &#125;,  <figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">3.</span> 配置按需加载，动态导入</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span> ```<span class="javascript">javascript</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;hello main&quot;</span>);</span></span><br><span class="line"><span class="javascript">      </span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 动态导入 --&gt; 实现按需加载</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 即使只被引用了一次，也会代码分割</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">import</span>(<span class="string">&quot;./math.js&quot;</span>).then(<span class="function">(<span class="params">&#123; sum &#125;</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          alert(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br></pre></td></tr></table></figure>2. 一旦通过 import 动态导入语法导入模块，模块就被代码分割，同时也能按需加载了</code></pre></li></ol></li><li><p>单入口</p><ol><li><p>单页面应用（spa），只有一个入口（单入口）</p></li><li><p>配置webpack</p><ol><li><pre><code class="javascript">const path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123;  // 单入口  entry: &quot;./src/main.js&quot;,  // 多入口  // entry: &#123;  //   main: &quot;./src/main.js&quot;,  //   app: &quot;./src/app.js&quot;,  // &#125;,  output: &#123;    path: path.resolve(__dirname, &quot;./dist&quot;),    // [name]是webpack命名规则，使用chunk的name作为输出的文件名。    // 什么是chunk？打包的资源就是chunk，输出出去叫bundle。    // chunk的name是啥呢？ 比如： entry中xxx: &quot;./src/xxx.js&quot;, name就是xxx。注意是前面的xxx，和文件名无关。    // 为什么需要这样命名呢？如果还是之前写法main.js，那么打包生成两个js文件都会叫做main.js会发生覆盖。(实际上会直接报错的)    filename: &quot;js/[name].js&quot;,    clean: true,  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;      template: &quot;./public/index.html&quot;,    &#125;),  ],  mode: &quot;production&quot;,  optimization: &#123;    // 代码分割配置    splitChunks: &#123;      chunks: &quot;all&quot;, // 对所有模块都进行分割      // 以下是默认值      // minSize: 20000, // 分割代码最小的大小      // minRemainingSize: 0, // 类似于minSize，最后确保提取的文件大小不能为0      // minChunks: 1, // 至少被引用的次数，满足条件才会代码分割      // maxAsyncRequests: 30, // 按需加载时并行加载的文件的最大数量      // maxInitialRequests: 30, // 入口js文件最大并行请求数量      // enforceSizeThreshold: 50000, // 超过50kb一定会单独打包（此时会忽略minRemainingSize、maxAsyncRequests、maxInitialRequests）      // cacheGroups: &#123; // 组，哪些模块要打包到一个组      //   defaultVendors: &#123; // 组名      //     test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块      //     priority: -10, // 权重（越大越高）      //     reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块      //   &#125;,      //   default: &#123; // 其他没有写的配置会使用上面的默认值      //     minChunks: 2, // 这里的minChunks权重更大      //     priority: -20,      //     reuseExistingChunk: true,      //   &#125;,      // &#125;,  &#125;,&#125;;<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2</span>. ```javascript</span><br><span class="line">       <span class="regexp">//</span> 代码分割配置</span><br><span class="line">       splitChunks: &#123;</span><br><span class="line">         chunks: <span class="string">&quot;all&quot;</span>, <span class="regexp">//</span> 对所有模块都进行分割</span><br><span class="line">         <span class="regexp">//</span> 其他内容用默认配置即可</span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></figure></code></pre></li><li><p>![image-20220607203135751](/Users/xiaotian/Library/Application Support/typora-user-images/image-20220607203135751.png)</p></li><li><p>给动态导入的文件取名</p><ol><li><p>修改main.js</p><ul><li><pre><code class="javascript">document.getElementById(&quot;btn&quot;).onClick = function () &#123;  // eslint会对动态导入语法报错，需要修改eslint配置文件  // webpackChunkName: &quot;math&quot;：这是webpack动态导入模块命名的方式  // &quot;math&quot;将来就会作为[name]的值显示。  import(/* webpackChunkName: &quot;math&quot; */ &quot;./js/math.js&quot;).then((&#123; count &#125;) =&gt; &#123;    console.log(count(2, 1));  &#125;);&#125;;<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2.</span> 下载包 `npm i eslint-plugin-import -D`</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 配置eslint</span><br><span class="line"></span><br><span class="line">   - ```javascript</span><br><span class="line">     <span class="comment">// .eslintrc.js</span></span><br><span class="line">     module.exports = &#123;</span><br><span class="line">       <span class="comment">// 继承 Eslint 规则</span></span><br><span class="line"><span class="symbol">       extends:</span> [<span class="string">&quot;eslint:recommended&quot;</span>],</span><br><span class="line"><span class="symbol">       env:</span> &#123;</span><br><span class="line"><span class="symbol">         node:</span> true, <span class="comment">// 启用node中全局变量</span></span><br><span class="line"><span class="symbol">         browser:</span> true, <span class="comment">// 启用浏览器中全局变量</span></span><br><span class="line">       &#125;,</span><br><span class="line"><span class="symbol">       plugins:</span> [<span class="string">&quot;import&quot;</span>], <span class="comment">// 解决动态导入import语法报错问题 --&gt; 实际使用eslint-plugin-import的规则解决的</span></span><br><span class="line"><span class="symbol">       parserOptions:</span> &#123;</span><br><span class="line"><span class="symbol">         ecmaVersion:</span> <span class="number">6</span>,</span><br><span class="line"><span class="symbol">         sourceType:</span> <span class="string">&quot;module&quot;</span>,</span><br><span class="line">       &#125;,</span><br><span class="line"><span class="symbol">       rules:</span> &#123;</span><br><span class="line">         <span class="string">&quot;no-var&quot;</span>: <span class="number">2</span>, <span class="comment">// 不能使用 var 定义变量</span></span><br><span class="line">       &#125;,</span><br><span class="line">     &#125;;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>配置webpack，统一命名</p><ul><li><pre><code class="javascript">filename: &quot;static/js/[name].js&quot;, // 入口文件打包输出资源命名方式    chunkFilename: &quot;static/js/[name].chunk.js&quot;, // 动态导入输出资源命名方式    assetModuleFilename: &quot;static/media/[name].[hash][ext]&quot;, // 图片、字体等资源命名方式（注意用hash）<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">            -</span> ![<span class="string">image-20220608111206852</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220608111206852.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">            -</span> ![<span class="string">image-20220608111226416</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220608111226416.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">### preload/prefetch</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 之前做了代码分割后实现了按需加载（也就是懒加载）</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> 但是速度不够快，比如一个按钮用户点击了才加载资源，如果该资源非常大的话会有明显的卡顿现象</span><br><span class="line"><span class="bullet">   2.</span> 因此我们想在浏览器空闲的时候加载后续需要使用的资源（预加载）</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> <span class="code">`Preload`</span>：告诉浏览器立即加载资源。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> <span class="code">`Prefetch`</span>：告诉浏览器在空闲时才开始加载资源。</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> <span class="code">`Preload`</span> 与 <span class="code">`Prefetch`</span> 共同点</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> 只加载资源，并不执行</span><br><span class="line"><span class="bullet">   2.</span> 都有缓存</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> <span class="code">`Preload`</span> 与 <span class="code">`Prefetch`</span> 区别</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> <span class="code">`Preload`</span>加载优先级高，<span class="code">`Prefetch`</span>加载优先级低。</span><br><span class="line"><span class="bullet">   2.</span> <span class="code">`preload`</span>只加载当前页面需要使用的资源，<span class="code">`prefetch`</span>可以加载当前页面需要使用的资源，也可以加载下一个页面需要使用的资源</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> 兼容性比较差，<span class="code">`preload`</span>兼容性要高一点</span><br><span class="line"></span><br><span class="line"><span class="bullet">7.</span> 配置</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> 下载包 <span class="code">`npm i @vue/preload-webpack-plugin -D`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   2.</span> <span class="code">```javascript</span></span><br><span class="line"><span class="code">      // css压缩</span></span><br><span class="line"><span class="code">          // new CssMinimizerPlugin(),</span></span><br><span class="line"><span class="code">          new PreloadWebpackPlugin(&#123;</span></span><br><span class="line"><span class="code">            rel: &quot;preload&quot;, // preload兼容性更好</span></span><br><span class="line"><span class="code">            as: &quot;script&quot;,</span></span><br><span class="line"><span class="code">            // rel: &#x27;prefetch&#x27; // prefetch兼容性更差</span></span><br><span class="line"><span class="code">          &#125;),</span></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ol></li></ol></li><li><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220608114848178.png" alt="image-20220608114848178"></p></li></ol></li></ol><h3 id="network-cache"><a href="#network-cache" class="headerlink" title="network cache"></a>network cache</h3><ol><li><p>对静态资源使用缓存来优化，浏览器再二次请求直接读取缓存，速度更快</p></li><li><p>回出现一个问题：前后输出的文件名都是一样的，发布新版本浏览器会读取缓存，不会加载新资源</p><ol><li>我们要从文件名入手，确保更新后的文件名与之前不一样</li></ol></li><li><p>使用hash</p><ul><li><p>fullhash（webpack4 是 hash）每次修改任何一个文件，所有文件名的 hash 至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效。</p></li><li><p>chunkhash 根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。我们 js 和 css 是同一个引入，会共享一个 hash 值。</p></li><li><p>contenthash 根据文件内容生成 hash 值，只有文件内容变化了，hash 值才会变化。所有文件 hash 值是独享且不同的。</p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220608120638753.png" alt="image-20220608120638753"></p></li><li><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220608120658005.png" alt="image-20220608120658005"></p></li></ul></li><li><p>出现问题：只修改了一个文件，但是main.js的hash也发生了变化，缓存失效</p><ol><li><p>原因：引用的文件发生变化，导致main.js的content也发生了变化，最终main.js生成新的hash，是我们不希望看到的</p></li><li><p>解决</p><ol><li><p>将hash值单独保存在runtime文件中</p></li><li><p>runtime 文件只保存文件的 hash 值和它们与文件关系，整个文件体积就比较小，所以变化重新请求的代价也小。</p></li><li><pre><code class="javascript">    // 提取runtime文件    runtimeChunk: &#123;      name: (entrypoint) =&gt; `runtime~$&#123;entrypoint.name&#125;`, // runtime文件命名规则    &#125;,<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">### core-js</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> babel已经对js代码进行了一定的兼容性处理，我们使用 @babel/preset-env 智能预设来处理兼容性</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> 但是es6有些语法并没有编译转换，比如箭头函数，promise， async等</span><br><span class="line"><span class="bullet">   2.</span> 所以还是存在一定的兼容性问题，遇到低版本浏览器可能出现报错</span><br><span class="line"></span><br><span class="line"><span class="bullet">2.</span> <span class="code">`core-js`</span> 是专门用来做 ES6 以及以上 API 的 <span class="code">`polyfill`</span>。</span><br><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 配置webpack</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> 下载包 <span class="code">`npm i @babel/eslint-parser -D`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   2.</span> 下载包 <span class="code">`npm i core-js`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   3.</span> 可以手动全部引入和手动按需引入（体积大/麻烦）</span><br><span class="line"></span><br><span class="line"><span class="bullet">      1.</span> <span class="code">```javascript</span></span><br><span class="line"><span class="code">         import &quot;core-js&quot;;</span></span><br></pre></td></tr></table></figure></code></pre></li><li><pre><code class="javascript">import &quot;core-js/es/promise&quot;;<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">4.</span> 配置自动按需引入</span><br><span class="line"></span><br><span class="line">   <span class="number">1.</span> 配置babel.config.js</span><br><span class="line"></span><br><span class="line">   <span class="number">2.</span> ```javascript</span><br><span class="line">      module.exports = &#123;</span><br><span class="line">        <span class="comment">// 智能预设：能够编译ES6语法</span></span><br><span class="line">        <span class="symbol">presets:</span> [</span><br><span class="line">          [</span><br><span class="line">            <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">            <span class="comment">// 按需加载core-js的polyfill</span></span><br><span class="line">            &#123; <span class="attr">useBuiltIns:</span> <span class="string">&quot;usage&quot;</span>, <span class="attr">corejs:</span> &#123; <span class="attr">version:</span> <span class="string">&quot;3&quot;</span>, <span class="attr">proposals:</span> <span class="literal">true</span> &#125; &#125;,</span><br><span class="line">          ],</span><br><span class="line">        ],</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ol></li></ol><h3 id="pwa"><a href="#pwa" class="headerlink" title="pwa"></a>pwa</h3><ol><li><p>希望提供离线服务</p></li><li><p>配置webpack</p><ol><li><p>下载包 <code>npm i workbox-webpack-plugin -D</code></p></li><li><p>修改webpack.config.js</p><ol><li><pre><code class="javascript">const WorkboxPlugin = require(&quot;workbox-webpack-plugin&quot;);<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2</span><span class="string">.</span> <span class="string">```javascript</span></span><br><span class="line">   <span class="string">new</span> <span class="string">WorkboxPlugin.GenerateSW(&#123;</span></span><br><span class="line">         <span class="string">//</span> <span class="string">这些选项帮助快速启用</span> <span class="string">ServiceWorkers</span></span><br><span class="line">         <span class="string">//</span> <span class="string">不允许遗留任何“旧的”</span> <span class="string">ServiceWorkers</span></span><br><span class="line">         <span class="attr">clientsClaim:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">         <span class="attr">skipWaiting:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">       <span class="string">&#125;),</span></span><br></pre></td></tr></table></figure></code></pre></li><li><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220608122751327.png" alt="image-20220608122751327"></p></li></ol></li><li><p>修改main.js</p><ul><li><pre><code class="javascript">if (&quot;serviceWorker&quot; in navigator) &#123;  window.addEventListener(&quot;load&quot;, () =&gt; &#123;    navigator.serviceWorker      .register(&quot;/service-worker.js&quot;)      .then((registration) =&gt; &#123;        console.log(&quot;SW registered: &quot;, registration);      &#125;)      .catch((registrationError) =&gt; &#123;        console.log(&quot;SW registration failed: &quot;, registrationError);      &#125;);  &#125;);&#125;</code></pre></li></ul></li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Webpack高级优化&quot;&gt;&lt;a href=&quot;#Webpack高级优化&quot; class=&quot;headerlink&quot; title=&quot;Webpack高级优化&quot;&gt;&lt;/a&gt;Webpack高级优化&lt;/h1&gt;&lt;h2 id=&quot;提升开发体验&quot;&gt;&lt;a href=&quot;#提升开发体验&quot; class=&quot;headerlink&quot; title=&quot;提升开发体验&quot;&gt;&lt;/a&gt;提升开发体验&lt;/h2&gt;&lt;h3 id=&quot;sourcemap&quot;&gt;&lt;a href=&quot;#sourcemap&quot; class=&quot;headerlink&quot; title=&quot;sourcemap&quot;&gt;&lt;/a&gt;sourcemap&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打包完后的代码不便与阅读&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因此需要sourcemap来生成源代码与构建后代码的一一映射&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;会生成xxx.map文件，包含源代码与构建后代码每一行，每一列的映射关系&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果构建代码出错，通过xxx.map文件可以定位到源代码出错位置&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Webpack" scheme="http://example.com/categories/Webpack/"/>
    
    
    <category term="Webpack" scheme="http://example.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Webpack基础配置</title>
    <link href="http://example.com/2021/06/15/Webpack%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2021/06/15/Webpack%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</id>
    <published>2021-06-15T13:41:31.000Z</published>
    <updated>2022-06-23T04:26:44.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Webpack基础配置"><a href="#Webpack基础配置" class="headerlink" title="Webpack基础配置"></a>Webpack基础配置</h1><h2 id="五个概念"><a href="#五个概念" class="headerlink" title="五个概念"></a>五个概念</h2><ol><li>entry 入口<ul><li>指示webpack从哪个文件开始打包</li></ul></li><li>output 出口<ul><li>打包完的文件输出到哪里去，以及如何命名</li></ul></li><li>loader 加载器<ul><li>webpack本身只处理js，json等资源</li><li>其他资源需要借助loader才能解析</li></ul></li><li>plugins 插件<ul><li>扩展webpack功能</li></ul></li><li>mode 模式<ul><li>开发模式 development</li><li>生产模式 production</li></ul></li></ol><span id="more"></span><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><ol><li>基础配置文件<ul><li>在根目录创建 <code>webpack.config.js</code>文件</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node.js的核心模块，专门处理文件路径</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 入口</span></span><br><span class="line">    entry: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    <span class="comment">// 出口</span></span><br><span class="line">    output : &#123;</span><br><span class="line">        <span class="comment">// path 文件输出目录，必须是绝对路径</span></span><br><span class="line">        <span class="comment">// path.resolve() 返回一个绝对路径</span></span><br><span class="line">        <span class="comment">// __dirname 当前文件所在绝对路径</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        filename: <span class="string">&#x27;main.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 加载器</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 插件</span></span><br><span class="line">    plugins: [],</span><br><span class="line">    <span class="comment">// 模式</span></span><br><span class="line">    mode : <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>运行 <code>npx webpack</code>进行打包</li></ol><h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><ul><li>主要做两件事<ol><li>编译代码，使浏览器能识别运行<ul><li>样式</li><li>字体</li><li>图片</li><li>html</li></ul></li><li>代码质量检查，设置代码规范<ul><li>提前检查代码隐患，使代码更健壮</li><li>统一团队编码风格</li></ul></li></ol></li></ul><h3 id="处理样式资源"><a href="#处理样式资源" class="headerlink" title="处理样式资源"></a>处理样式资源</h3><ol><li><p>css</p><ul><li><p>下载两个loader <code>npm i css-loader style-loader -D</code></p></li><li><p>配置module</p><ul><li><pre><code class="javascript">module: &#123;        rules: [            &#123;                test: /\.css$/,                use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ]            &#125;        ],    &#125;,<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     - ![image-<span class="number">20220606201544356</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220606201544356</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. less </span><br><span class="line"></span><br><span class="line">   - 下载less loader `npm i less-loader -D`</span><br><span class="line"></span><br><span class="line">   - 配置module</span><br><span class="line"></span><br><span class="line">     - ```javascript</span><br><span class="line">       &#123;</span><br><span class="line">               test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">               use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],</span><br><span class="line">             &#125;,</span><br></pre></td></tr></table></figure></code></pre></li><li><p>use中的loader是从后往前执行，因此less-loader 需要放在 style-loader 与 css-loader之后</p></li></ul></li></ul></li><li><p>sass/scss</p><ul><li><p>下载sass-loader <code>npm i sass-loader sass -D</code></p></li><li><p>配置module</p><ul><li><pre><code class="javascript">&#123;        test: /\.s[ac]ss$/,        use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;],      &#125;,<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">4</span>. styl</span><br><span class="line"></span><br><span class="line">   - 下载stylus-loader `npm i stylus-loader -D`</span><br><span class="line"></span><br><span class="line">   - 配置module</span><br><span class="line"></span><br><span class="line">     - ```javascript</span><br><span class="line">       &#123;</span><br><span class="line"><span class="title">               test:</span> /\.styl$/,</span><br><span class="line"><span class="title">               use:</span> [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;stylus-loader&quot;</span>],</span><br><span class="line">             &#125;,</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ol><h3 id="处理图片资源"><a href="#处理图片资源" class="headerlink" title="处理图片资源"></a>处理图片资源</h3><ol><li><p>webpack5已经内置了 file-loader 和 url-loader  两个loader</p></li><li><p>只需要在module中进行配置即可</p><ul><li><pre><code class="javascript">&#123;        test: /\.(png|jpe?g|gif|webp)$/,        type: &quot;asset&quot;,      &#125;,<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">3.</span> 优化图片资源</span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> 将小于某大小的图片转换为data url （base64）</span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> 优点：减少请求数量</span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> 缺点：体积变大</span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">```javascript</span></span><br><span class="line"><span class="code">     parser: &#123;</span></span><br><span class="line"><span class="code">               dataUrlCondition: &#123;</span></span><br><span class="line"><span class="code">                 maxSize: 10 * 1024 // 小于10kb的图片会被base64处理</span></span><br><span class="line"><span class="code">               &#125;</span></span><br><span class="line"><span class="code">             &#125;</span></span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ol><h3 id="修改输出资源的名称和路径"><a href="#修改输出资源的名称和路径" class="headerlink" title="修改输出资源的名称和路径"></a>修改输出资源的名称和路径</h3><ol><li><p>修改js文件路径</p><ul><li><code>filename: &quot;static/js/main.js&quot;,</code></li><li><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220606224701172.png" alt="image-20220606224701172"></li></ul></li><li><p>修改html引入</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220606224741833.png" alt="image-20220606224741833"></li></ul></li><li><p>修改图片输出路径以及命名</p><ul><li><pre><code class="javascript">generator: &#123;                    // 将图片文件输出到 static/imgs 目录中                    // 将图片文件命名 [hash:8][ext][query]                    // [hash:8]: hash值取8位                    // [ext]: 使用之前的文件扩展名                    // [query]: 添加之前的query参数                    filename: &quot;static/imgs/[hash:8][ext][query]&quot;,                &#125;,<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - ![image-<span class="number">20220606224852478</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220606224852478</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 自动清空上次打包资源</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 配置output</span><br><span class="line">   - `clean: true`</span><br><span class="line">   - ![image-<span class="number">20220606225727622</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220606225727622</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 处理字体图标资源</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 配置loader</span><br><span class="line"></span><br><span class="line">   - ```javascript</span><br><span class="line">     &#123;</span><br><span class="line">                     test: <span class="regexp">/\.(ttf|woff2?)$/</span>,</span><br><span class="line">                     type: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">                     generator: &#123;</span><br><span class="line">                         filename: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span>,</span><br><span class="line">                     &#125;,</span><br><span class="line">                 &#125;,</span><br></pre></td></tr></table></figure></code></pre></li><li><p><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220606230029205.png" alt="image-20220606230029205"></p></li></ul></li></ol><h3 id="处理js资源"><a href="#处理js资源" class="headerlink" title="处理js资源"></a>处理js资源</h3><ol><li><p>处理代码格式，使用eslint</p><ol><li><p>在根目录创建 .eslintrc.js 文件</p></li><li><p>配置 .eslintrc.js文件</p></li><li><pre><code class="javascript">module.exports = &#123;    // 解析选项    parserOptions: &#123;        ecmaVersion: 6, // ES 语法版本        sourceType: &quot;module&quot;, // ES 模块化        ecmaFeatures: &#123; // ES 其他特性            jsx: true // 如果是 React 项目，就需要开启 jsx 语法        &#125;    &#125;,    // 继承其他规则，后期配置react项目可以继承react官方规则    extends: [&quot;react-app&quot;],    // 覆盖继承的规则，一个一个手rules写过于复杂    rules: &#123;        // 我们的规则会覆盖掉react-app的规则        semi: &quot;error&quot;, // 禁止使用分号        &#39;array-callback-return&#39;: &#39;warn&#39;, // 强制数组方法的回调函数中有 return 语句，否则警告        &#39;default-case&#39;: [            &#39;warn&#39;, // 要求 switch 语句中有 default 分支，否则警告            &#123; commentPattern: &#39;^no default$&#39; &#125; // 允许在最后注释 no default, 就不会有警告了        ],        eqeqeq: [            &#39;warn&#39;, // 强制使用 === 和 !==，否则警告            &#39;smart&#39; // https://eslint.bootcss.com/docs/rules/eqeqeq#smart 除了少数情况下不会有警告        ],    &#125;,    // ...    // 其他规则详见：https://eslint.bootcss.com/docs/user-guide/configuring&#125;;<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">4.</span> ![<span class="string">image-20220607000245951</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607000245951.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">5.</span> rules具体规则</span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">`&quot;off&quot;`</span> 或 <span class="code">`0`</span> - 关闭规则</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`&quot;warn&quot;`</span> 或 <span class="code">`1`</span> - 开启规则，使用警告级别的错误：<span class="code">`warn`</span> (不会导致程序退出)</span><br><span class="line"><span class="bullet">   -</span> <span class="code">`&quot;error&quot;`</span> 或 <span class="code">`2`</span> - 开启规则，使用错误级别的错误：<span class="code">`error`</span> (当被触发的时候，程序会退出)</span><br><span class="line"></span><br><span class="line"><span class="bullet">6.</span> 下载包 <span class="code">`npm i eslint-webpack-plugin eslint -D`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">7.</span> 配置webpack.config.js文件</span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">`const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> <span class="code">```javascript</span></span><br><span class="line"><span class="code">     plugins: [</span></span><br><span class="line"><span class="code">         new ESLintWebpackPlugin(&#123;</span></span><br><span class="line"><span class="code">           // 指定检查文件的根目录</span></span><br><span class="line"><span class="code">           context: path.resolve(__dirname, &quot;src&quot;),</span></span><br><span class="line"><span class="code">         &#125;),</span></span><br><span class="line"><span class="code">       ],</span></span><br></pre></td></tr></table></figure>- ![image-20220607000723823](https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607000723823.png)- ![image-20220607000745553](https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607000745553.png)</code></pre></li><li><p>为了更好的开发体验，可以下载vscode的eslint插件，并且配置 .eslintignore 文件，忽略dist文件夹</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607001010979.png" alt="image-20220607001010979"></li></ul></li></ol></li><li><p>处理兼容性，使用babel</p><ol><li><p>在根目录创建 babel.config.js 文件</p></li><li><p>下载相关包 <code>npm i babel-loader @babel/core @babel/preset-env -D</code></p></li><li><p>配置 babel.config.js 文件</p><ol><li><p>presets 预设</p><ol><li><code>@babel/preset-env</code>: 一个智能预设，允许您使用最新的 JavaScript。</li><li><code>@babel/preset-react</code>：一个用来编译 React jsx 语法的预设</li><li><code>@babel/preset-typescript</code>：一个用来编译 TypeScript 语法的预设</li></ol></li><li><pre><code class="javascript">module.exports = &#123;    // 预设    presets: [&quot;@babel/preset-env&quot;],&#125;;<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">4</span>. 配置 webpack.config.js 文件</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. 排除 node_modules 文件夹</span><br><span class="line"></span><br><span class="line">   <span class="number">2</span>. ```javascript</span><br><span class="line">      &#123;</span><br><span class="line">              test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">              exclude: <span class="regexp">/node_modules/</span>, <span class="regexp">//</span> 排除node_modules代码不编译</span><br><span class="line">              loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">            &#125;,</span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ol></li></ol><h3 id="处理Html资源"><a href="#处理Html资源" class="headerlink" title="处理Html资源"></a>处理Html资源</h3><ol><li><p>安装插件 <code>npm i html-webpack-plugin -D</code></p></li><li><p>配置 web pack.config.js 文件</p><ol><li><p><code>const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);</code></p></li><li><pre><code class="javascript">new HtmlWebpackPlugin(&#123;      // 以 public/index.html 为模板创建文件      // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源      template: path.resolve(__dirname, &quot;public/index.html&quot;),    &#125;),<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">3</span>. 打包后的html会自动引入js文件，因此index.html中不需要手动引入了</span><br><span class="line"><span class="number">4</span>. ![image-<span class="number">20220607150650273</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607150650273</span>.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 开发服务器 &amp; 自动化</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 下载包 `npm i webpack-dev-server -D`</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 配置 webpack.config.js 文件</span><br><span class="line"></span><br><span class="line">   - ```javascript</span><br><span class="line">     <span class="regexp">//</span> 开发服务器</span><br><span class="line">       devServer: &#123;</span><br><span class="line">         host: <span class="string">&quot;localhost&quot;</span>, <span class="regexp">//</span> 启动服务器域名</span><br><span class="line">         port: <span class="string">&quot;3000&quot;</span>, <span class="regexp">//</span> 启动服务器端口号</span><br><span class="line">         open: true, <span class="regexp">//</span> 是否自动打开浏览器</span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></figure></code></pre></li></ol></li><li><p>当启用开发服务器后，所有代码都在内存中编译打包，因此并不会输出到dist目录下</p></li></ol><h2 id="生产模式"><a href="#生产模式" class="headerlink" title="生产模式"></a>生产模式</h2><ul><li><p>优化代码运行性能</p></li><li><p>优化代码打包速度</p></li></ul><ol><li><p>分别配置开发环境与生产环境文件，存入config文件夹</p><ul><li><img src="https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607154900222.png"></li><li>因为存入了config文件夹，因此需要修改webpack配置文件中的路径</li></ul></li><li><p>配置package.json简化命令</p><ul><li><pre><code class="json">  // 其他省略  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;npm run dev&quot;,    &quot;dev&quot;: &quot;npx webpack serve --config ./config/webpack.dev.js&quot;,    &quot;build&quot;: &quot;npx webpack --config ./config/webpack.prod.js&quot;  &#125;<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - ![image-<span class="number">20220607155141887</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607155141887</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">### css处理</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 目前css文件被打包到js文件中，当js文件加载时，会创建style标签来生成样式</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 网速慢的时候会产生屏闪现象</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 应该将css文件单独出来，用link标签加载，性能更好</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. 配置webpack文件</span><br><span class="line"></span><br><span class="line">   - `const MiniCssExtractPlugin = require(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);`</span><br><span class="line"></span><br><span class="line">   - 替换所有的style-loader</span><br><span class="line"></span><br><span class="line">   - ![image-<span class="number">20220607155949418</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607155949418</span>.png)</span><br><span class="line"></span><br><span class="line">   - 提取css成单独文件</span><br><span class="line"></span><br><span class="line">     - ```javascript</span><br><span class="line">       <span class="regexp">//</span> 提取css成单独文件</span><br><span class="line">           new MiniCssExtractPlugin(&#123;</span><br><span class="line">             <span class="regexp">//</span> 定义输出文件名和目录</span><br><span class="line">             filename: <span class="string">&quot;static/css/main.css&quot;</span>,</span><br><span class="line">           &#125;),</span><br></pre></td></tr></table></figure>- ![image-20220607160048147](https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607160048147.png)</code></pre></li></ul></li><li><p>css兼容性处理</p><ol><li><p>下载包 <code>npm i postcss-loader postcss postcss-preset-env -D</code></p></li><li><p>配置webpack文件</p><ul><li><p>在css-loader之后添加配置</p></li><li><pre><code class="javascript">&#123;            loader: &quot;postcss-loader&quot;,            options: &#123;              postcssOptions: &#123;                plugins: [                  &quot;postcss-preset-env&quot;, // 能解决大多数样式兼容性问题                ],              &#125;,            &#125;,          &#125;,<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - ![image-<span class="number">20220607160452201</span>](https:<span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>chiguayeshao<span class="regexp">/pic-bed/im</span>age-<span class="number">20220607160452201</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 控制兼容性</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>. 在package.json中配置 browserslist</span><br><span class="line"></span><br><span class="line">      - 兼容到 ie8</span><br><span class="line"></span><br><span class="line">        - ```json</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="regexp">//</span> 其他省略</span><br><span class="line">            <span class="string">&quot;browserslist&quot;</span>: [<span class="string">&quot;ie &gt;= 8&quot;</span>]</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure> - 不考虑旧版本浏览器   - ```json     &#123;       // 其他省略       &quot;browserslist&quot;: [&quot;last 2 version&quot;, &quot;&gt; 1%&quot;, &quot;not dead&quot;]     &#125;     <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">      -</span> ![<span class="string">image-20220607161009633</span>](<span class="link">https://cdn.jsdelivr.net/gh/chiguayeshao/pic-bed/image-20220607161009633.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">4.</span> css压缩</span><br><span class="line"></span><br><span class="line"><span class="bullet">   1.</span> 下载插件包 <span class="code">`npm i css-minimizer-webpack-plugin -D`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   2.</span> 配置webpack文件</span><br><span class="line"></span><br><span class="line"><span class="bullet">      1.</span> <span class="code">`const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);`</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">      2.</span> <span class="code">```javascript</span></span><br><span class="line"><span class="code">         // css压缩</span></span><br><span class="line"><span class="code">             new CssMinimizerPlugin(),</span></span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>html压缩</p><ol><li>默认生产模式已经开启了：html 压缩和 js 压缩</li><li>不需要额外进行配置</li></ol></li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Webpack基础配置&quot;&gt;&lt;a href=&quot;#Webpack基础配置&quot; class=&quot;headerlink&quot; title=&quot;Webpack基础配置&quot;&gt;&lt;/a&gt;Webpack基础配置&lt;/h1&gt;&lt;h2 id=&quot;五个概念&quot;&gt;&lt;a href=&quot;#五个概念&quot; class=&quot;headerlink&quot; title=&quot;五个概念&quot;&gt;&lt;/a&gt;五个概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;entry 入口&lt;ul&gt;
&lt;li&gt;指示webpack从哪个文件开始打包&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;output 出口&lt;ul&gt;
&lt;li&gt;打包完的文件输出到哪里去，以及如何命名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;loader 加载器&lt;ul&gt;
&lt;li&gt;webpack本身只处理js，json等资源&lt;/li&gt;
&lt;li&gt;其他资源需要借助loader才能解析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;plugins 插件&lt;ul&gt;
&lt;li&gt;扩展webpack功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;mode 模式&lt;ul&gt;
&lt;li&gt;开发模式 development&lt;/li&gt;
&lt;li&gt;生产模式 production&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Webpack" scheme="http://example.com/categories/Webpack/"/>
    
    
    <category term="Webpack" scheme="http://example.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客增加live2d</title>
    <link href="http://example.com/2020/12/16/Hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0live2d/"/>
    <id>http://example.com/2020/12/16/Hexo%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0live2d/</id>
    <published>2020-12-16T13:37:45.000Z</published>
    <updated>2020-12-16T14:36:07.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo博客增加live2d插件"><a href="#Hexo博客增加live2d插件" class="headerlink" title="Hexo博客增加live2d插件"></a>Hexo博客增加live2d插件</h1><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><ol><li>cmd进入到你的博客文件夹路径下</li><li>使用 <code>npm i hexo-helper-live2d --save</code> 安装依赖</li></ol><a id="more"></a><ol><li><p>安装成功后博客的package.json文件下会自动加入该包</p><p><img src="https://i.loli.net/2020/12/16/M3UrCJqVPN6Zp8K.png" alt="image-20201216215110041"></p></li></ol><h1 id="live2d-Model下载"><a href="#live2d-Model下载" class="headerlink" title="live2d Model下载"></a>live2d Model下载</h1><ol><li><p>进入GitHub下载<a href="https://github.com/xiazeyu/live2d-widget-models">live2d模型</a></p><p><img src="https://i.loli.net/2020/12/16/VZtsIemwj1h3TDl.png" alt="image-20201216215300880"></p></li><li><p>解压出该文件夹中的packages文件</p></li><li><p>将packages文件中的model复制到博客文件夹下的node_modules文件夹中</p><p><img src="https://i.loli.net/2020/12/16/6sZixo5y9IRnktT.png" alt="image-20201216222846076"></p></li></ol><h1 id="修改博客配置文件"><a href="#修改博客配置文件" class="headerlink" title="修改博客配置文件"></a>修改博客配置文件</h1><ol><li><p>进入博客的配置文件_config.yml，增加以下配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#是否开启看板</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-hijiki</span> <span class="comment">#想切换模型直接修改为node_modules中的liv2d的各模型文件名称</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span> <span class="comment">#在右边显示</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span> <span class="comment">#看板的宽</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">345</span> <span class="comment">#看板的高</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span>  <span class="comment">#是否在手机进行显示</span></span><br></pre></td></tr></table></figure></li><li><p>想要预览live2d挑选喜欢的模型可以访问该<a href="https://huaji8.top/post/live2d-plugin-2.0/">网站</a></p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Hexo博客增加live2d插件&quot;&gt;&lt;a href=&quot;#Hexo博客增加live2d插件&quot; class=&quot;headerlink&quot; title=&quot;Hexo博客增加live2d插件&quot;&gt;&lt;/a&gt;Hexo博客增加live2d插件&lt;/h1&gt;&lt;h2 id=&quot;插件安装&quot;&gt;&lt;a href=&quot;#插件安装&quot; class=&quot;headerlink&quot; title=&quot;插件安装&quot;&gt;&lt;/a&gt;插件安装&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;cmd进入到你的博客文件夹路径下&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;npm i hexo-helper-live2d --save&lt;/code&gt; 安装依赖&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="博客配置与搭建" scheme="http://example.com/categories/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Live2d" scheme="http://example.com/tags/Live2d/"/>
    
  </entry>
  
  <entry>
    <title>一键配置SSL证书</title>
    <link href="http://example.com/2020/12/15/%E4%B8%80%E9%94%AE%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/"/>
    <id>http://example.com/2020/12/15/%E4%B8%80%E9%94%AE%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6/</id>
    <published>2020-12-15T12:38:18.000Z</published>
    <updated>2020-12-15T13:02:40.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github-Hexo博客一键配置证书"><a href="#Github-Hexo博客一键配置证书" class="headerlink" title="Github+Hexo博客一键配置证书"></a>Github+Hexo博客一键配置证书</h1><h1 id="一键配置"><a href="#一键配置" class="headerlink" title="一键配置"></a>一键配置</h1><ol><li><p>进入GitHub，找到博客所部署的仓库</p></li><li><p>点击Setting</p><p><img src="https://i.loli.net/2020/12/15/5SH98wXszenDiQW.png" alt="image-20201215204100107"></p></li></ol><a id="more"></a><ol><li><p>下拉找到GitHub Pages，勾选Enforce HTTPS</p><p><img src="https://i.loli.net/2020/12/15/tzY2wFrpsNum3XE.png" alt="image-20201215204231362"></p></li><li><p>证书配置完毕</p><p><img src="https://i.loli.net/2020/12/15/qXyrSZeQd7pW5Cv.png" alt="image-20201215204310992"></p></li></ol><h1 id="还想bb两句"><a href="#还想bb两句" class="headerlink" title="还想bb两句"></a>还想bb两句</h1><h2 id="通过Freessl获取免费证书"><a href="#通过Freessl获取免费证书" class="headerlink" title="通过Freessl获取免费证书"></a>通过Freessl获取免费证书</h2><ol><li><p>获取免费证书推荐通过FreeSSl<a href="https://freessl.cn/">官网</a></p></li><li><p>输入你的域名，点击创建证书</p><p><img src="https://i.loli.net/2020/12/15/Pg9wuTGWRZbpXrj.png" alt="image-20201215204649089"></p></li><li><p>之后应该会要求注册登录，输入邮箱为了快速方便选择浏览器生成(推荐chrome)</p><p><img src="https://i.loli.net/2020/12/15/ZTPO5sM3qdgDHBk.png" alt="image-20201215204827876"></p></li><li><p>之后会自动将私钥下载到本地，并且页面会如图所示要求DNS验证</p><p><img src="https://i.loli.net/2020/12/15/gxUdY75pABn2amo.png" alt="image-20201215205007751"></p></li><li><p>进入域名商网站配置域名(我用的是Godaddy<a href="https://www.godaddy.com/">官网</a>，其他供应商大同小异)</p><ul><li><p>根据freessl提示配置TXT记录</p><ul><li><p>Type输入TXT</p></li><li><p>Name输入freessl的TXT记录内容</p><p><img src="https://i.loli.net/2020/12/15/4AVpLatovb2TkhY.png" alt="image-20201215205413553"></p></li><li><p>Value输入freessl的记录值内容</p><p><img src="https://i.loli.net/2020/12/15/9lPns1VMHfTkXyx.png" alt="image-20201215205458547"></p></li></ul></li><li><p>然后回到freessl点击 配置完成，检测一下</p></li><li><p>检查成功后可以点击 点击验证按钮，生成免费的SSL证书</p></li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Github-Hexo博客一键配置证书&quot;&gt;&lt;a href=&quot;#Github-Hexo博客一键配置证书&quot; class=&quot;headerlink&quot; title=&quot;Github+Hexo博客一键配置证书&quot;&gt;&lt;/a&gt;Github+Hexo博客一键配置证书&lt;/h1&gt;&lt;h1 id=&quot;一键配置&quot;&gt;&lt;a href=&quot;#一键配置&quot; class=&quot;headerlink&quot; title=&quot;一键配置&quot;&gt;&lt;/a&gt;一键配置&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进入GitHub，找到博客所部署的仓库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;点击Setting&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/15/5SH98wXszenDiQW.png&quot; alt=&quot;image-20201215204100107&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="博客配置与搭建" scheme="http://example.com/categories/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Github+Hexo+NexT搭建个人博客（Windows）</title>
    <link href="http://example.com/2020/12/14/Github-Hexo-NexT%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88Windows%EF%BC%89/"/>
    <id>http://example.com/2020/12/14/Github-Hexo-NexT%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%88Windows%EF%BC%89/</id>
    <published>2020-12-14T14:32:56.000Z</published>
    <updated>2020-12-14T16:22:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Github-Hexo-NexT搭建个人博客（Windows）"><a href="#Github-Hexo-NexT搭建个人博客（Windows）" class="headerlink" title="Github+Hexo+NexT搭建个人博客（Windows）"></a>Github+Hexo+NexT搭建个人博客（Windows）</h1><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ol><li>GitHub仓库</li><li>安装Git</li><li>安装Node.js</li><li>安装Hexo</li><li>安装Next主题</li><li>购买域名</li></ol><span id="more"></span><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><ol><li><p>进入Git官网<a href="https://git-scm.com/download/win">下载</a></p></li><li><p>根据你的电脑选择64位或32位版本</p><p><img src="https://i.loli.net/2020/12/14/uDjagzShdHbJs6M.png" alt="image-20201214215323884"></p></li><li><p>无脑点击下一步，直到安装完成</p></li></ol><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><ol><li><p>进入Node官网<a href="https://nodejs.org/en/download/">下载</a></p></li><li><p>根据你的电脑选择64位或32位版本</p><p><img src="https://i.loli.net/2020/12/14/7TdBAfmkriUSnKy.png" alt="image-20201214215254079"></p></li><li><p>无脑点击下一步，直到安装完成</p></li><li><p>测试是否安装成功：注意安装Node会同时安装npm</p><ul><li><p>打开命令行工具，输入<code>git -v</code> 查看Node是否安装成功</p></li><li><p>如图，显示Git版本则安装成功</p><p><img src="https://i.loli.net/2020/12/14/2Nm7nexZw31Cubp.png" alt="image-20201214221400043"></p></li><li><p>打开命令行工具，输入<code>npm -v</code> 查看npm是否安装成功</p></li><li><p>如图，显示npm版本则安装成功</p><p><img src="https://i.loli.net/2020/12/14/6OWRcPpxjGgl5Ls.png" alt="image-20201214221424224"></p></li></ul></li></ol><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><ol><li><p>选择合适的位置创建一个文件夹</p></li><li><p>输入cmd，打开命令行工具并定位到该文件夹</p><p><img src="https://i.loli.net/2020/12/14/KvIb7apfV9ASxOh.png" alt="image-20201214222613531"></p></li><li><p>使用npm命令安装Hexo</p><p><code>npm install hexo-cli -g</code></p></li><li><p>使用Hexo初始化博客</p><p><code>hexo init blogName</code></p><ul><li>blogName是你想要的任意名字</li><li>将创建出一个名为blogName的文件夹</li></ul></li><li><p>检查博客状态</p><ol><li><p>按顺序输入命令</p><p><code>hexo g</code></p><p><code>hexo s</code></p></li><li><p>在浏览器中输入loclhost:4000</p></li></ol></li><li><p>如图，博客初具形态，由于我做过些配置修改，因此和你的页面显示不完全一样。</p><p><img src="https://i.loli.net/2020/12/14/QZJR9ncsrTl5twm.png" alt="image-20201214221612356"></p></li></ol><h2 id="Github创建仓库"><a href="#Github创建仓库" class="headerlink" title="Github创建仓库"></a>Github创建仓库</h2><ol><li><p>Repository name需要创建为 username.github.io</p><ul><li>username是你的Github用户名</li></ul></li><li><p>使用Git Bash配置ssh密钥，连接GitHub</p><p><img src="https://i.loli.net/2020/12/14/TugAJGOYsCQf7mh.png" alt="image-20201214221753832"></p><ul><li><p>输入以下命令，设置username和useremail</p><p><code>git config --global user.name &quot;你的GitHub用户名&quot;</code></p><p><code>git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></p></li><li><p>输入以下命令生成密钥文件(无脑回车)</p><p><code>ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot;</code></p></li><li><p>找到密钥文件，一般在C:\Users\username.ssh路径下，复制密钥内容</p><p><img src="https://i.loli.net/2020/12/14/c19gwksSavRVdym.png" alt="image-20201214222149511"></p></li><li><p>进入Github Setting页面</p><p><img src="https://i.loli.net/2020/12/14/doeuLRa9mj58ZfW.png" alt="image-20201214222315041"></p></li><li><p>new SSH KEY</p><p><img src="https://i.loli.net/2020/12/14/AFa91eMnJWgSIti.png" alt="image-20201214222419096"></p><ul><li><p>title随意，key输入刚刚复制的密钥内容</p><p><img src="https://i.loli.net/2020/12/14/3kt7D8MKSFv12go.png" alt="image-20201214222512434"></p></li></ul></li></ul></li></ol><ol start="3"><li><p>至此配置完毕，将博客推送至GitHub，执行以下命令<br><code>hexo clean</code></p><p><code>hexo g</code></p><p><code>hexo d</code></p><ul><li>可以看到GitHub中已经有了我们的博客文件</li></ul></li><li><p>在浏览器中输入username.github.io访问博客</p></li></ol><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><ol><li><p>购买域名我推荐使用美区<a href="https://www.godaddy.com/offers/brand/new?isc=gofd2001aj&gclid=CjwKCAiAlNf-BRB_EiwA2osbxfBGER8_uvJGversF6txxsoGmWe-xcdK-SKtMlx08j7nU5M105M1gxoCU4cQAvD_BwE&gclsrc=aw.ds">Godaddy</a>（需要科学上网），其他途径如阿里云，腾讯云等可自行购买</p></li><li><p>注册Godaddy</p></li><li><p>输入你想要的域名</p><p><img src="https://i.loli.net/2020/12/14/bryT2CNck3MYxt5.png" alt="image-20201214215405386"></p></li><li><p>根据经济实力选择购买域名</p></li><li><p>配置域名，将域名与博客绑定</p><ul><li><p>进入Godaddy控制面板</p></li><li><p>选择你购买的域名，点击DNS开始配置DNS</p></li></ul><p><img src="https://i.loli.net/2020/12/14/QoSdh5H9OwnMpqP.png" alt="image-20201214215554340"></p><ul><li><p>添加一条A记录，value填入ip地址（ip地址通过 <code>ping username.github.io</code>获得）</p><p><img src="https://i.loli.net/2020/12/14/zyV31FjWvq4KoQm.png" alt="image-20201214221158651"></p></li><li><p>添加一条CNAME记录，value填入username.github.io`</p></li></ul><p><img src="https://i.loli.net/2020/12/14/NTOSvQCJo3rgdyw.png" alt="image-20201214220124019"></p></li></ol><ol start="6"><li><p>配置博客</p><ul><li><p>进入博客目录中的source文件夹</p><p><img src="https://i.loli.net/2020/12/15/79tWVbOZUAMvQpi.png" alt="image-20201214220627487"></p></li><li><p>在source文件夹中新建一个没有后缀名的文件，文件名为CNAME</p><p><img src="https://i.loli.net/2020/12/14/gJPBdjL4tIQi2Zf.png" alt="image-20201214220736897"></p></li><li><p>编辑CNAME文件，在文件中输入你的域名</p><p><img src="https://i.loli.net/2020/12/14/ZSKLxwszYn1amvH.png" alt="image-20201214220910202"></p></li></ul></li></ol><ol start="7"><li>配置完毕，在浏览器中输入域名访问，测试域名是否绑定成功</li></ol><h2 id="安装NexT主题"><a href="#安装NexT主题" class="headerlink" title="安装NexT主题"></a>安装NexT主题</h2><ol><li><p>安装，执行以下命令</p><p><code>npm install hexo-theme-next</code></p><p><code>git clone https://github.com/next-theme/hexo-theme-next themes/next</code></p></li><li><p>修改配置文件</p><p><img src="https://i.loli.net/2020/12/14/HhBmITV18tAe7Nd.png" alt="image-20201214222836213"></p><ul><li>将theme的的内容更改为next</li><li>重新执行以下命令可使next主题生效<ul><li><code>hexo g</code></li><li><code>hexo d</code></li></ul></li></ul></li><li><p>NexT主题的详细操作可访问<a href="https://theme-next.iissnan.com/getting-started.html">NexT官网</a>查看进阶功能或<a href="https://github.com/next-theme/hexo-theme-next">GitHub地址</a></p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>根据Hexo<a href="https://hexo.io/zh-cn/docs/">官网文档</a>和NexT<a href="https://theme-next.iissnan.com/">官网文档</a>，我们可以高度自定义我们的博客</li><li>具体如何自定义使博客内容更丰富，我将在之后的文章中一一道来</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Github-Hexo-NexT搭建个人博客（Windows）&quot;&gt;&lt;a href=&quot;#Github-Hexo-NexT搭建个人博客（Windows）&quot; class=&quot;headerlink&quot; title=&quot;Github+Hexo+NexT搭建个人博客（Windows）&quot;&gt;&lt;/a&gt;Github+Hexo+NexT搭建个人博客（Windows）&lt;/h1&gt;&lt;h2 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;GitHub仓库&lt;/li&gt;
&lt;li&gt;安装Git&lt;/li&gt;
&lt;li&gt;安装Node.js&lt;/li&gt;
&lt;li&gt;安装Hexo&lt;/li&gt;
&lt;li&gt;安装Next主题&lt;/li&gt;
&lt;li&gt;购买域名&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="博客配置与搭建" scheme="http://example.com/categories/%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
